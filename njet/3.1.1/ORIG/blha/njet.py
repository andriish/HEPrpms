#!/usr/bin/env python

# blha/njet.py
#
# This file is part of NJet library
# Copyright (C) 2011, 2012, 2013 NJet Collaboration
#
# This software is distributed under the terms of the GNU General Public License (GPL)

import argparse
import os.path
import re
from functools import reduce

import operator
import sys

try:
    # for Python 2
    from StringIO import StringIO
except ImportError:
    # for Python 3
    from io import StringIO

__all__ = ["OLP_Start", "OLP_EvalSubProcess", "OLP"]

NJETBANNER = "# Generated by njet.py, do not edit by hand.\n"

NJETSIGNED = "# Signed by NJet {}.\n"
NJETSIGNED_PAT = r"^\s*# Signed by NJet "

# lh format version (should be the same as in njet_olp.cpp)
FORMAT_VERSION = 1025


class Channel:
    eqQCD = [[1, 2, 3, 4, 5, 6], [11, 13, 15]]
    eqSM = [[1, 3, 5], [2, 4, 6], ([11, 13, 15], [12, 14, 16])]

    uneqUPDOWN = [
        11,
        13,
        15,
        12,
        14,
        16,
        22,
    ]  # particles which make up-down quarks unequal

    fvnames = {
        1: "d",
        2: "u",
        3: "s",
        4: "c",
        5: "b",
        6: "t",
        -1: "d",
        -2: "u",
        -3: "s",
        -4: "c",
        -5: "b",
        -6: "t",
        21: "G",
        22: "A",
        25: "H",
        (12, -11): "W",
        (11, -11): "Z",
    }

    name2id = {}

    current = 0

    @staticmethod
    def generate_chnum(fv_list):
        Channel.current += 1
        return Channel.current

    @staticmethod
    def generate_name(fv_list):
        s = []
        i = 0
        while i < len(fv_list):
            fv = fv_list[i]
            if fv not in Channel.fvnames:
                fv = tuple(fv_list[i : i + 2])
                i += 1
            i += 1
            try:
                s.append(Channel.fvnames[fv])
            except KeyError:
                s.append("X")
        return "".join(s)

    def __init__(
        self,
        fv_list,
        order=None,
        nocross=None,
        equiv=None,
        name=None,
        kind="full",
        has_lc=None,
        has_ax=None,
        has_hq=None,
    ):
        self.fv_list = fv_list
        if order is None:
            order = list(range(1, len(fv_list) + 1))
        self.fv_order = order
        self.fv_equiv = self.assign_equiv(equiv)
        self.fv_map = self.get_map_equiv()

        self.canon_list, self.canon_order = self.get_canonical()

        if name is None:
            self.name = Channel.generate_name(fv_list)
            self.ch = Channel.generate_chnum(fv_list)
        elif name not in Channel.name2id:
            self.name = name
            self.ch = Channel.generate_chnum(fv_list)
        else:
            self.name = name
            self.ch = Channel.name2id[name]
        Channel.name2id[self.name] = self.ch

        self.kind = kind
        if has_lc is None and kind == "full":
            has_lc = True
        self.has_lc = has_lc
        self.has_ax = has_ax
        self.has_hq = has_hq

        if not nocross:
            self.fv_nocross = []
            self.fv_cross = []
        else:
            symm_fv = self.fv_list[nocross[0] - 1]
            assert all(self.fv_list[nc - 1] == symm_fv for nc in nocross)
            self.fv_nocross = nocross
            self.fv_cross = [
                i + 1
                for i, fv in enumerate(self.fv_list)
                if fv == symm_fv and i + 1 not in nocross
            ]
        self.fv_symm = self.fv_cross + self.fv_nocross

    def assign_equiv(self, fv_equiv):
        if fv_equiv is not None:
            return fv_equiv
        else:
            if any(abs(f) in Channel.uneqUPDOWN for f in self.fv_list):
                return Channel.eqSM
            else:
                return Channel.eqQCD

    def get_map_equiv(self, fv_equiv=None):
        if fv_equiv is None:
            fv_equiv = self.fv_equiv
        fmap = {}
        for eq in fv_equiv:
            eqx = eq
            if isinstance(eqx, tuple):
                eqx = eqx[0]
                eq = list(zip(*eq))
            m = [self.fv_list.count(f) + self.fv_list.count(-f) for f in eqx]
            mz = list(zip(m, eq))
            mult = list(reversed(sorted(mz)))
            for ((s, f1), f2) in zip(mult, eq):
                if s == 0:
                    continue
                elif isinstance(f1, tuple):
                    fmap.update(dict(list(zip(list(f1), list(f2)))))
                    fmap.update(
                        dict(list(zip(list(-x for x in f1), list(-x for x in f2))))
                    )
                else:
                    fmap[f1] = f2
                    fmap[-f1] = -f2
        return fmap

    def remap(self, fv_list=None):
        if fv_list is None:
            fv_list = self.fv_list
        new_list = []
        for fv in fv_list:
            new_list.append(self.fv_map.get(fv, fv))
        return new_list

    def get_canonical(self):
        new_list = self.remap()
        return list(zip(*sorted(zip(new_list, self.fv_order))))


class ChannelMapperBase(object):
    # primitive process table
    # default kind='full' and has_lc=True
    channel_list = [
        # QCD-channels
        Channel([21, 21, 21, 21], has_lc=False, has_hq=True),  # GGGG
        Channel([-1, 1, 21, 21], has_lc=False, has_hq=True),  # ddGG
        Channel([-1, 1, -2, 2], has_lc=False, has_hq=True),  # dduu
        Channel([-1, 1, -1, 1], has_lc=False, has_hq=True),  # dddd
        Channel([21, 21, 21, 21, 21], has_lc=False, has_hq=True),  # GGGGG
        Channel([-1, 1, 21, 21, 21], has_hq=True),  # ddGGG
        Channel([-1, 1, -2, 2, 21], has_hq=True),  # dduuG
        Channel([-1, 1, -1, 1, 21], has_hq=True),  # ddddG
        Channel([21, 21, 21, 21, 21, 21], has_lc=False, has_hq=True),  # GGGGGG
        Channel([-1, 1, 21, 21, 21, 21], has_hq=True),  # ddGGGG
        Channel([-1, 1, -2, 2, 21, 21], has_hq=True),  # dduuGG
        Channel([-1, 1, -1, 1, 21, 21], has_hq=True),  # ddddGG
        Channel([-1, 1, -2, 2, -3, 3], has_hq=True),  # dduuss
        Channel([-2, 2, -1, 1, -1, 1], has_hq=True),  # uudddd
        Channel([-1, 1, -1, 1, -1, 1], has_hq=True),  # dddddd
        Channel([21, 21, 21, 21, 21, 21, 21], has_lc=False),  # GGGGGGG
        Channel([-1, 1, 21, 21, 21, 21, 21]),  # ddGGGGG
        Channel([-1, 1, -2, 2, 21, 21, 21]),  # dduuGGG
        Channel([-1, 1, -1, 1, 21, 21, 21]),  # ddddGGG
        Channel([-1, 1, -2, 2, -3, 3, 21]),  # dduussG
        Channel([-2, 2, -1, 1, -1, 1, 21]),  # uuddddG
        Channel([-1, 1, -1, 1, -1, 1, 21]),  # ddddddG
        # W-channels (up and down flavours are different)
        Channel([-2, 1, 12, -11], has_lc=False),  # udW
        Channel([-2, 1, 21, 12, -11], has_lc=False),  # udGW
        Channel([-2, 1, 21, 21, 12, -11], has_lc=False),  # udGGW
        Channel([-2, 1, -3, 3, 12, -11], has_lc=False),  # udssW
        Channel([-2, 1, -4, 4, 12, -11], has_lc=False),  # udccW
        Channel([-2, 1, -1, 1, 12, -11], has_lc=False),  # udddW
        Channel([-2, 1, -2, 2, 12, -11], has_lc=False),  # uduuW
        Channel([-2, 1, 21, 21, 21, 12, -11]),  # udGGGW
        Channel([-2, 1, -3, 3, 21, 12, -11]),  # udssGW
        Channel([-2, 1, -4, 4, 21, 12, -11]),  # udccGW
        Channel([-2, 1, -1, 1, 21, 12, -11]),  # udddGW
        Channel([-2, 1, -2, 2, 21, 12, -11]),  # uduuGW
        Channel([-2, 1, 21, 21, 21, 21, 12, -11]),  # udGGGGW
        Channel([-2, 1, -3, 3, 21, 21, 12, -11]),  # udssGGW
        Channel([-2, 1, -4, 4, 21, 21, 12, -11]),  # udccGGW
        Channel([-2, 1, -1, 1, 21, 21, 12, -11]),  # udddGGW
        Channel([-2, 1, -2, 2, 21, 21, 12, -11]),  # uduuGGW
        Channel([-2, 1, -3, 3, -4, 4, 12, -11]),  # udssccW
        Channel([-2, 1, -3, 3, -5, 5, 12, -11]),  # udssbbW
        Channel([-2, 1, -4, 4, -6, 6, 12, -11]),  # udccttW
        Channel([-2, 1, -3, 3, -3, 3, 12, -11]),  # udssssW
        Channel([-2, 1, -4, 4, -4, 4, 12, -11]),  # udccccW
        Channel([-2, 1, -1, 1, -3, 3, 12, -11]),  # udddssW
        Channel([-2, 1, -1, 1, -4, 4, 12, -11]),  # udddccW
        Channel([-2, 1, -2, 2, -3, 3, 12, -11]),  # uduussW
        Channel([-2, 1, -2, 2, -4, 4, 12, -11]),  # uduuccW
        Channel([-2, 1, -1, 1, -1, 1, 12, -11]),  # udddddW
        Channel([-2, 1, -2, 2, -2, 2, 12, -11]),  # uduuuuW
        Channel([-2, 1, -1, 1, -2, 2, 12, -11]),  # uddduuW
        Channel([-2, 1, 21, 21, 21, 21, 21, 12, -11]),  # udGGGGGW
        Channel([-2, 1, -3, 3, 21, 21, 21, 12, -11]),  # udssGGGW
        Channel([-2, 1, -4, 4, 21, 21, 21, 12, -11]),  # udccGGGW
        Channel([-2, 1, -1, 1, 21, 21, 21, 12, -11]),  # udddGGGW
        Channel([-2, 1, -2, 2, 21, 21, 21, 12, -11]),  # uduuGGGW
        Channel([-2, 1, -3, 3, -4, 4, 21, 12, -11]),  # udssccGW
        Channel([-2, 1, -3, 3, -5, 5, 21, 12, -11]),  # udssbbGW
        Channel([-2, 1, -4, 4, -6, 6, 21, 12, -11]),  # udccttGW
        Channel([-2, 1, -3, 3, -3, 3, 21, 12, -11]),  # udssssGW
        Channel([-2, 1, -4, 4, -4, 4, 21, 12, -11]),  # udccccGW
        Channel([-2, 1, -1, 1, -3, 3, 21, 12, -11]),  # udddssGW
        Channel([-2, 1, -1, 1, -4, 4, 21, 12, -11]),  # udddccGW
        Channel([-2, 1, -2, 2, -3, 3, 21, 12, -11]),  # uduussGW
        Channel([-2, 1, -2, 2, -4, 4, 21, 12, -11]),  # uduuccGW
        Channel([-2, 1, -1, 1, -1, 1, 21, 12, -11]),  # udddddGW
        Channel([-2, 1, -2, 2, -2, 2, 21, 12, -11]),  # uduuuuGW
        Channel([-2, 1, -1, 1, -2, 2, 21, 12, -11]),  # uddduuGW
        # Z-channels (up and down flavours are different)
        Channel([-1, 1, 11, -11], has_lc=False),  # ddZ
        Channel([-2, 2, 11, -11], has_lc=False),  # uuZ
        Channel([-1, 1, 21, 11, -11], has_lc=False),  # ddGZ
        Channel([-2, 2, 21, 11, -11], has_lc=False),  # uuGZ
        Channel([-1, 1, 21, 21, 11, -11], has_lc=False),  # ddGGZ
        Channel([-2, 2, 21, 21, 11, -11], has_lc=False),  # uuGGZ
        Channel([-1, 1, -3, 3, 11, -11], has_lc=False),  # ddssZ
        Channel([-1, 1, -2, 2, 11, -11], has_lc=False),  # dduuZ
        Channel([-2, 2, -4, 4, 11, -11], has_lc=False),  # uuccZ
        Channel([-1, 1, -1, 1, 11, -11], has_lc=False),  # ddddZ
        Channel([-2, 2, -2, 2, 11, -11], has_lc=False),  # uuuuZ
        Channel([-1, 1, 21, 21, 21, 11, -11]),  # ddGGGZ
        Channel([-2, 2, 21, 21, 21, 11, -11]),  # uuGGGZ
        Channel([-1, 1, -3, 3, 21, 11, -11]),  # ddssGZ
        Channel([-1, 1, -2, 2, 21, 11, -11]),  # dduuGZ
        Channel([-2, 2, -4, 4, 21, 11, -11]),  # uuccGZ
        Channel([-1, 1, -1, 1, 21, 11, -11]),  # ddddGZ
        Channel([-2, 2, -2, 2, 21, 11, -11]),  # uuuuGZ
        Channel([-1, 1, 21, 21, 21, 21, 11, -11]),  # ddGGGGZ
        Channel([-2, 2, 21, 21, 21, 21, 11, -11]),  # uuGGGGZ
        Channel([-1, 1, -3, 3, 21, 21, 11, -11]),  # ddssGGZ
        Channel([-1, 1, -2, 2, 21, 21, 11, -11]),  # dduuGGZ
        Channel([-2, 2, -4, 4, 21, 21, 11, -11]),  # uuccGGZ
        Channel([-1, 1, -1, 1, 21, 21, 11, -11]),  # ddddGGZ
        Channel([-2, 2, -2, 2, 21, 21, 11, -11]),  # uuuuGGZ
        Channel([-1, 1, -3, 3, -5, 5, 11, -11]),  # ddssbbZ
        Channel([-2, 2, -4, 4, -6, 6, 11, -11]),  # uuccttZ
        Channel([-1, 1, -3, 3, -2, 2, 11, -11]),  # ddssuuZ
        Channel([-2, 2, -4, 4, -1, 1, 11, -11]),  # uuccddZ
        Channel([-1, 1, -1, 1, -3, 3, 11, -11]),  # ddddssZ
        Channel([-2, 2, -2, 2, -4, 4, 11, -11]),  # uuuuccZ
        Channel([-1, 1, -1, 1, -2, 2, 11, -11]),  # dddduuZ
        Channel([-2, 2, -2, 2, -1, 1, 11, -11]),  # uuuuddZ
        Channel([-1, 1, -1, 1, -1, 1, 11, -11]),  # ddddddZ
        Channel([-2, 2, -2, 2, -2, 2, 11, -11]),  # uuuuuuZ
        Channel([-1, 1, 21, 21, 21, 21, 21, 11, -11]),  # ddGGGGGZ
        Channel([-2, 2, 21, 21, 21, 21, 21, 11, -11]),  # uuGGGGGZ
        Channel([-1, 1, -3, 3, 21, 21, 21, 11, -11]),  # ddssGGGZ
        Channel([-1, 1, -2, 2, 21, 21, 21, 11, -11]),  # dduuGGGZ
        Channel([-2, 2, -4, 4, 21, 21, 21, 11, -11]),  # uuccGGGZ
        Channel([-1, 1, -1, 1, 21, 21, 21, 11, -11]),  # ddddGGGZ
        Channel([-2, 2, -2, 2, 21, 21, 21, 11, -11]),  # uuuuGGGZ
        Channel([-1, 1, -3, 3, -5, 5, 21, 11, -11]),  # ddssbbGZ
        Channel([-2, 2, -4, 4, -6, 6, 21, 11, -11]),  # uuccttGZ
        Channel([-1, 1, -3, 3, -2, 2, 21, 11, -11]),  # ddssuuGZ
        Channel([-2, 2, -4, 4, -1, 1, 21, 11, -11]),  # uuccddGZ
        Channel([-1, 1, -1, 1, -3, 3, 21, 11, -11]),  # ddddssGZ
        Channel([-2, 2, -2, 2, -4, 4, 21, 11, -11]),  # uuuuccGZ
        Channel([-1, 1, -1, 1, -2, 2, 21, 11, -11]),  # dddduuGZ
        Channel([-2, 2, -2, 2, -1, 1, 21, 11, -11]),  # uuuuddGZ
        Channel([-1, 1, -1, 1, -1, 1, 21, 11, -11]),  # ddddddGZ
        Channel([-2, 2, -2, 2, -2, 2, 21, 11, -11]),  # uuuuuuGZ
        # A-channels (up and down flavours are different)
        Channel([-1, 1, 21, 22], has_lc=False),  # ddGA
        Channel([-2, 2, 21, 22], has_lc=False),  # uuGA
        Channel([-1, 1, 21, 21, 22], has_lc=False, has_ax=True),  # ddGGA
        Channel([-2, 2, 21, 21, 22], has_lc=False, has_ax=True),  # uuGGA
        Channel([-1, 1, -3, 3, 22], has_lc=False, has_ax=True),  # ddssA
        Channel([-1, 1, -2, 2, 22], has_lc=False, has_ax=True),  # dduuA
        Channel([-2, 2, -4, 4, 22], has_lc=False, has_ax=True),  # uuccA
        Channel([-1, 1, -1, 1, 22], has_lc=False, has_ax=True),  # ddddA
        Channel([-2, 2, -2, 2, 22], has_lc=False, has_ax=True),  # uuuuA
        Channel([-1, 1, 21, 21, 21, 22], has_ax=True),  # ddGGGA
        Channel([-2, 2, 21, 21, 21, 22], has_ax=True),  # uuGGGA
        Channel([-1, 1, -3, 3, 21, 22], has_ax=True),  # ddssGA
        Channel([-1, 1, -2, 2, 21, 22], has_ax=True),  # dduuGA
        Channel([-2, 2, -4, 4, 21, 22], has_ax=True),  # uuccGA
        Channel([-1, 1, -1, 1, 21, 22], has_ax=True),  # ddddGA
        Channel([-2, 2, -2, 2, 21, 22], has_ax=True),  # uuuuGA
        Channel([-1, 1, 21, 21, 21, 21, 22]),  # ddGGGGA
        Channel([-2, 2, 21, 21, 21, 21, 22]),  # uuGGGGA
        Channel([-1, 1, -3, 3, 21, 21, 22]),  # ddssGGA
        Channel([-1, 1, -2, 2, 21, 21, 22]),  # dduuGGA
        Channel([-2, 2, -4, 4, 21, 21, 22]),  # uuccGGA
        Channel([-1, 1, -1, 1, 21, 21, 22]),  # ddddGGA
        Channel([-2, 2, -2, 2, 21, 21, 22]),  # uuuuGGA
        Channel([-1, 1, -3, 3, -5, 5, 22]),  # ddssbbA
        Channel([-2, 2, -4, 4, -6, 6, 22]),  # uuccttA
        Channel([-1, 1, -3, 3, -2, 2, 22]),  # ddssuuA
        Channel([-2, 2, -4, 4, -1, 1, 22]),  # uuccddA
        Channel([-1, 1, -1, 1, -3, 3, 22]),  # ddddssA
        Channel([-2, 2, -2, 2, -4, 4, 22]),  # uuuuccA
        Channel([-1, 1, -1, 1, -2, 2, 22]),  # dddduuA
        Channel([-2, 2, -2, 2, -1, 1, 22]),  # uuuuddA
        Channel([-1, 1, -1, 1, -1, 1, 22]),  # ddddddA
        Channel([-2, 2, -2, 2, -2, 2, 22]),  # uuuuuuA
        Channel([-1, 1, 21, 21, 21, 21, 21, 22]),  # ddGGGGGA
        Channel([-2, 2, 21, 21, 21, 21, 21, 22]),  # uuGGGGGA
        Channel([-1, 1, -3, 3, 21, 21, 21, 22]),  # ddssGGGA
        Channel([-1, 1, -2, 2, 21, 21, 21, 22]),  # dduuGGGA
        Channel([-2, 2, -4, 4, 21, 21, 21, 22]),  # uuccGGGA
        Channel([-1, 1, -1, 1, 21, 21, 21, 22]),  # ddddGGGA
        Channel([-2, 2, -2, 2, 21, 21, 21, 22]),  # uuuuGGGA
        Channel([-1, 1, -3, 3, -5, 5, 21, 22]),  # ddssbbGA
        Channel([-2, 2, -4, 4, -6, 6, 21, 22]),  # uuccttGA
        Channel([-1, 1, -3, 3, -2, 2, 21, 22]),  # ddssuuGA
        Channel([-2, 2, -4, 4, -1, 1, 21, 22]),  # uuccddGA
        Channel([-1, 1, -1, 1, -3, 3, 21, 22]),  # ddddssGA
        Channel([-2, 2, -2, 2, -4, 4, 21, 22]),  # uuuuccGA
        Channel([-1, 1, -1, 1, -2, 2, 21, 22]),  # dddduuGA
        Channel([-2, 2, -2, 2, -1, 1, 21, 22]),  # uuuuddGA
        Channel([-1, 1, -1, 1, -1, 1, 21, 22]),  # ddddddGA
        Channel([-2, 2, -2, 2, -2, 2, 21, 22]),  # uuuuuuGA
        # AA-channels (up and down flavours are different)
        Channel([-1, 1, 22, 22], has_lc=False),  # ddAA
        Channel([-2, 2, 22, 22], has_lc=False),  # uuAA
        Channel([21, 21, 22, 22], has_ax=False, has_lc=False),  # GGAA
        Channel([-1, 1, 21, 22, 22], has_lc=False, has_ax=True),  # ddGAA
        Channel([-2, 2, 21, 22, 22], has_lc=False, has_ax=True),  # uuGAA
        Channel([21, 21, 21, 22, 22], has_ax=False, has_lc=False),  # GGGAA
        Channel([-1, 1, 21, 21, 22, 22], has_lc=False, has_ax=True),  # ddGGAA
        Channel([-2, 2, 21, 21, 22, 22], has_lc=False, has_ax=True),  # uuGGAA
        Channel([-1, 1, -3, 3, 22, 22], has_lc=False, has_ax=True),  # ddssAA
        Channel([-1, 1, -2, 2, 22, 22], has_lc=False, has_ax=True),  # dduuAA
        Channel([-2, 2, -4, 4, 22, 22], has_lc=False, has_ax=True),  # uuccAA
        Channel([-1, 1, -1, 1, 22, 22], has_lc=False, has_ax=True),  # ddddAA
        Channel([-2, 2, -2, 2, 22, 22], has_lc=False, has_ax=True),  # uuuuAA
        Channel([21, 21, 21, 21, 22, 22], has_ax=False, has_lc=False),  # GGGGAA
        Channel([-1, 1, 21, 21, 21, 22, 22]),  # ddGGGAA
        Channel([-2, 2, 21, 21, 21, 22, 22]),  # uuGGGAA
        Channel([-1, 1, -3, 3, 21, 22, 22]),  # ddssGAA
        Channel([-1, 1, -2, 2, 21, 22, 22]),  # dduuGAA
        Channel([-2, 2, -4, 4, 21, 22, 22]),  # uuccGAA
        Channel([-1, 1, -1, 1, 21, 22, 22]),  # ddddGAA
        Channel([-2, 2, -2, 2, 21, 22, 22]),  # uuuuGAA
        Channel([-1, 1, 21, 21, 21, 21, 22, 22]),  # ddGGGGAA
        Channel([-2, 2, 21, 21, 21, 21, 22, 22]),  # uuGGGGAA
        Channel([-1, 1, -3, 3, 21, 21, 22, 22]),  # ddssGGAA
        Channel([-1, 1, -2, 2, 21, 21, 22, 22]),  # dduuGGAA
        Channel([-2, 2, -4, 4, 21, 21, 22, 22]),  # uuccGGAA
        Channel([-1, 1, -1, 1, 21, 21, 22, 22]),  # ddddGGAA
        Channel([-2, 2, -2, 2, 21, 21, 22, 22]),  # uuuuGGAA
        Channel([-1, 1, -3, 3, -5, 5, 22, 22]),  # ddssbbAA
        Channel([-2, 2, -4, 4, -6, 6, 22, 22]),  # uuccttAA
        Channel([-1, 1, -3, 3, -2, 2, 22, 22]),  # ddssuuAA
        Channel([-2, 2, -4, 4, -1, 1, 22, 22]),  # uuccddAA
        Channel([-1, 1, -1, 1, -3, 3, 22, 22]),  # ddddssAA
        Channel([-2, 2, -2, 2, -4, 4, 22, 22]),  # uuuuccAA
        Channel([-1, 1, -1, 1, -2, 2, 22, 22]),  # dddduuAA
        Channel([-2, 2, -2, 2, -1, 1, 22, 22]),  # uuuuddAA
        Channel([-1, 1, -1, 1, -1, 1, 22, 22]),  # ddddddAA
        Channel([-2, 2, -2, 2, -2, 2, 22, 22]),  # uuuuuuAA
        # H-channels
        Channel([21, 21, 21, 25], has_lc=False, has_hq=True),  # GGGH
        Channel([-1, 1, 21, 25], has_lc=False, has_hq=True),  # uuGH
        Channel([21, 21, 21, 21, 25], has_lc=False, has_hq=True),  # GGGGH
        Channel([-1, 1, 21, 21, 25], has_lc=False, has_hq=True),  # ddGGH
        Channel([-1, 1, -2, 2, 25], has_lc=False, has_hq=True),  # dduuH
        Channel([-1, 1, -1, 1, 25], has_lc=False, has_hq=True),  # ddddH
        Channel([21, 21, 21, 21, 21, 25], has_lc=False, has_hq=True),  # GGGGGH
        Channel([-1, 1, 21, 21, 21, 25], has_lc=False, has_hq=True),  # ddGGGH
        Channel([-1, 1, -2, 2, 21, 25], has_lc=False, has_hq=True),  # dduuGH
        Channel([-1, 1, -1, 1, 21, 25], has_lc=False, has_hq=True),  # ddddGH
        Channel([21, 21, 21, 21, 21, 21, 25], has_lc=False, has_hq=True),  # GGGGGGH
        Channel([-1, 1, 21, 21, 21, 21, 25], has_lc=False, has_hq=True),  # ddGGGGH
        Channel([-1, 1, -2, 2, 21, 21, 25], has_lc=False, has_hq=True),  # dduuGGH
        Channel([-1, 1, -1, 1, 21, 21, 25], has_lc=False, has_hq=True),  # ddddGGH
        Channel([-1, 1, -2, 2, -3, 3, 25], has_lc=False, has_hq=True),  # dduussH
        Channel([-2, 2, -1, 1, -1, 1, 25], has_lc=False, has_hq=True),  # uuddddH
        Channel([-1, 1, -1, 1, -1, 1, 25], has_lc=False, has_hq=True),  # ddddddH
        # IMPORTANT: if there several DS alternatives for the same channel
        # they should be listed in ascending order (e.g. ds3, ds4, ds5)
        Channel(
            [21, 21, 21, 21, 21], name="GGGGGds3", kind="ds", nocross=[3, 4, 5]
        ),  # GGGGGds3
        Channel(
            [21, 21, 21, 21, 21, 21], name="GGGGGGds4", kind="ds", nocross=[3, 4, 5, 6],
        ),  # GGGGGGds4
        Channel(
            [21, 21, 21, 21, 21, 21, 21],
            name="GGGGGGGds5",
            kind="ds",
            nocross=[3, 4, 5, 6, 7],
        ),  # GGGGGGGds5
        Channel(
            [-1, 1, 21, 21, 21], name="ddGGGds3", kind="ds", nocross=[3, 4, 5]
        ),  # ddGGGds3
        Channel(
            [-1, 1, 21, 21, 21, 21], name="ddGGGGds3", kind="ds", nocross=[4, 5, 6],
        ),  # ddGGGGds3
        Channel(
            [-1, 1, 21, 21, 21, 21], name="ddGGGGds4", kind="ds", nocross=[3, 4, 5, 6],
        ),  # ddGGGGds4
        Channel(
            [-1, 1, 21, 21, 21, 21, 21],
            name="ddGGGGGds3",
            kind="ds",
            nocross=[5, 6, 7],
        ),  # ddGGGGGds3
        Channel(
            [-1, 1, 21, 21, 21, 21, 21],
            name="ddGGGGGds4",
            kind="ds",
            nocross=[4, 5, 6, 7],
        ),  # ddGGGGGds4
        Channel(
            [-1, 1, 21, 21, 21, 21, 21],
            name="ddGGGGGds5",
            kind="ds",
            nocross=[3, 4, 5, 6, 7],
        ),  # ddGGGGGds5
        Channel(
            [-2, 1, 21, 21, 21, 12, -11],
            name="udGGGWds3",
            kind="ds",
            nocross=[3, 4, 5],
        ),  # udGGGW
        Channel(
            [-1, 1, 21, 21, 21, 11, -11],
            name="ddGGGZds3",
            kind="ds",
            nocross=[3, 4, 5],
        ),  # ddGGGZ
        Channel(
            [-2, 2, 21, 21, 21, 11, -11],
            name="uuGGGZds3",
            kind="ds",
            nocross=[3, 4, 5],
        ),  # uuGGGZ
        Channel(
            [-1, 1, 21, 21, 21, 22], name="ddGGGAds3", kind="ds", nocross=[3, 4, 5],
        ),  # ddGGGA
        Channel(
            [-2, 2, 21, 21, 21, 22], name="uuGGGAds3", kind="ds", nocross=[3, 4, 5],
        ),  # uuGGGA
        Channel(
            [-2, 1, 21, 21, 21, 21, 12, -11],
            name="udGGGGWds3",
            kind="ds",
            nocross=[4, 5, 6],
        ),  # udGGGGWds3
        Channel(
            [-2, 1, 21, 21, 21, 21, 12, -11],
            name="udGGGGWds4",
            kind="ds",
            nocross=[3, 4, 5, 6],
        ),  # udGGGGWds4
        Channel(
            [-1, 1, 21, 21, 21, 21, 11, -11],
            name="ddGGGGZds3",
            kind="ds",
            nocross=[4, 5, 6],
        ),  # ddGGGGZds3
        Channel(
            [-1, 1, 21, 21, 21, 21, 11, -11],
            name="ddGGGGZds4",
            kind="ds",
            nocross=[3, 4, 5, 6],
        ),  # ddGGGGZds4
        Channel(
            [-2, 2, 21, 21, 21, 21, 11, -11],
            name="uuGGGGZds3",
            kind="ds",
            nocross=[4, 5, 6],
        ),  # uuGGGGZds3
        Channel(
            [-2, 2, 21, 21, 21, 21, 11, -11],
            name="uuGGGGZds4",
            kind="ds",
            nocross=[3, 4, 5, 6],
        ),  # uuGGGGZds4
        Channel(
            [-1, 1, 21, 21, 21, 21, 11, -11],
            name="ddGGGGZds3",
            kind="ds",
            nocross=[4, 5, 6],
        ),  # ddGGGGZds3
        Channel(
            [-1, 1, 21, 21, 21, 21, 11, -11],
            name="ddGGGGZds4",
            kind="ds",
            nocross=[3, 4, 5, 6],
        ),  # ddGGGGZds4
        Channel(
            [-2, 2, 21, 21, 21, 21, 11, -11],
            name="uuGGGGZds3",
            kind="ds",
            nocross=[4, 5, 6],
        ),  # uuGGGGZds3
        Channel(
            [-2, 2, 21, 21, 21, 21, 11, -11],
            name="uuGGGGZds4",
            kind="ds",
            nocross=[3, 4, 5, 6],
        ),  # uuGGGGZds4
        Channel(
            [-1, 1, 21, 21, 21, 21, 22],
            name="ddGGGGAds3",
            kind="ds",
            nocross=[4, 5, 6],
        ),  # ddGGGGAds3
        Channel(
            [-1, 1, 21, 21, 21, 21, 22],
            name="ddGGGGAds4",
            kind="ds",
            nocross=[3, 4, 5, 6],
        ),  # ddGGGGAds4
        Channel(
            [-2, 2, 21, 21, 21, 21, 22],
            name="uuGGGGAds3",
            kind="ds",
            nocross=[4, 5, 6],
        ),  # uuGGGGAds3
        Channel(
            [-2, 2, 21, 21, 21, 21, 22],
            name="uuGGGGAds4",
            kind="ds",
            nocross=[3, 4, 5, 6],
        ),  # uuGGGGAds4
        Channel(
            [-1, 1, 21, 21, 21, 21, 22, 22],
            name="ddGGGGAAds3",
            kind="ds",
            nocross=[4, 5, 6],
        ),  # ddGGGGAAds3
        Channel(
            [-1, 1, 21, 21, 21, 21, 22, 22],
            name="ddGGGGAAds4",
            kind="ds",
            nocross=[3, 4, 5, 6],
        ),  # ddGGGGAAds4
        Channel(
            [-2, 2, 21, 21, 21, 21, 22, 22],
            name="uuGGGGAAds3",
            kind="ds",
            nocross=[4, 5, 6],
        ),  # uuGGGGAAds3
        Channel(
            [-2, 2, 21, 21, 21, 21, 22, 22],
            name="uuGGGGAAds4",
            kind="ds",
            nocross=[3, 4, 5, 6],
        ),  # uuGGGGAAds4
        Channel(
            [-2, 1, 21, 21, 21, 21, 21, 12, -11],
            name="udGGGGGWds3",
            kind="ds",
            nocross=[5, 6, 7],
        ),  # udGGGGGWds3
        Channel(
            [-2, 1, 21, 21, 21, 21, 21, 12, -11],
            name="udGGGGGWds4",
            kind="ds",
            nocross=[4, 5, 6, 7],
        ),
        # udGGGGGWds4
        Channel(
            [-2, 1, 21, 21, 21, 21, 21, 12, -11],
            name="udGGGGGWds5",
            kind="ds",
            nocross=[3, 4, 5, 6, 7],
        ),
        # udGGGGGWds5
        Channel(
            [-1, 1, 21, 21, 21, 21, 21, 11, -11],
            name="ddGGGGGZds3",
            kind="ds",
            nocross=[5, 6, 7],
        ),  # ddGGGGGZds3
        Channel(
            [-1, 1, 21, 21, 21, 21, 21, 11, -11],
            name="ddGGGGGZds4",
            kind="ds",
            nocross=[4, 5, 6, 7],
        ),
        # ddGGGGGZds4
        Channel(
            [-1, 1, 21, 21, 21, 21, 21, 11, -11],
            name="ddGGGGGZds5",
            kind="ds",
            nocross=[3, 4, 5, 6, 7],
        ),
        # ddGGGGGZds5
        Channel(
            [-2, 2, 21, 21, 21, 21, 21, 11, -11],
            name="uuGGGGGZds3",
            kind="ds",
            nocross=[5, 6, 7],
        ),  # uuGGGGGZds3
        Channel(
            [-2, 2, 21, 21, 21, 21, 21, 11, -11],
            name="uuGGGGGZds4",
            kind="ds",
            nocross=[4, 5, 6, 7],
        ),
        # uuGGGGGZds4
        Channel(
            [-2, 2, 21, 21, 21, 21, 21, 11, -11],
            name="uuGGGGGZds5",
            kind="ds",
            nocross=[3, 4, 5, 6, 7],
        ),
        # uuGGGGGZds5
        Channel(
            [-1, 1, 21, 21, 21, 21, 21, 22],
            name="ddGGGGGAds3",
            kind="ds",
            nocross=[5, 6, 7],
        ),  # ddGGGGGAds3
        Channel(
            [-1, 1, 21, 21, 21, 21, 21, 22],
            name="ddGGGGGAds4",
            kind="ds",
            nocross=[4, 5, 6, 7],
        ),  # ddGGGGGAds4
        Channel(
            [-1, 1, 21, 21, 21, 21, 21, 22],
            name="ddGGGGGAds5",
            kind="ds",
            nocross=[3, 4, 5, 6, 7],
        ),  # ddGGGGGAds5
        Channel(
            [-2, 2, 21, 21, 21, 21, 21, 22],
            name="uuGGGGGAds3",
            kind="ds",
            nocross=[5, 6, 7],
        ),  # uuGGGGGAds3
        Channel(
            [-2, 2, 21, 21, 21, 21, 21, 22],
            name="uuGGGGGAds4",
            kind="ds",
            nocross=[4, 5, 6, 7],
        ),  # uuGGGGGAds4
        Channel(
            [-2, 2, 21, 21, 21, 21, 21, 22],
            name="uuGGGGGAds5",
            kind="ds",
            nocross=[3, 4, 5, 6, 7],
        ),  # uuGGGGGAds5
    ]

    canonical = {}


class Process(ChannelMapperBase):
    def initialize():
        # map W+ channels to W- by swapping u, d and e, nu
        new_channels = []
        for p in ChannelMapperBase.channel_list:
            if p.fv_list[:2] == [-2, 1] and p.fv_list[-2:] == [12, -11]:
                new_fv_list = list(p.fv_list)
                new_fv_list[0:2] = [-new_fv_list[1], -new_fv_list[0]]
                new_fv_list[-2:] = [-new_fv_list[-1], -new_fv_list[-2]]
                new_channels.append(
                    Channel(
                        new_fv_list,
                        name=p.name,
                        has_lc=p.has_lc,
                        kind=p.kind,
                        nocross=p.fv_nocross,
                        has_ax=p.has_ax,
                        has_hq=p.has_hq,
                    )
                )
        ChannelMapperBase.channel_list.extend(new_channels)

        # add LC and SLC channels
        new_channels_lc = []
        for p in ChannelMapperBase.channel_list:
            if p.has_lc:
                new_channels_lc.append(
                    Channel(p.fv_list, name=p.name + "_lc", kind="lc")
                )
        new_channels_slc = []
        for p in ChannelMapperBase.channel_list:
            if p.has_lc:
                new_channels_slc.append(
                    Channel(p.fv_list, name=p.name + "_slc", kind="slc")
                )
        new_channels_ax = []
        for p in ChannelMapperBase.channel_list:
            if p.has_ax:
                new_channels_ax.append(
                    Channel(p.fv_list, name=p.name + "_ax", kind="ax")
                )
        new_channels_hq = []
        for p in ChannelMapperBase.channel_list:
            if p.has_hq:
                new_channels_hq.append(
                    Channel(p.fv_list, name=p.name + "_hq", kind="hq")
                )
        ChannelMapperBase.channel_list.extend(new_channels_lc)
        ChannelMapperBase.channel_list.extend(new_channels_slc)
        ChannelMapperBase.channel_list.extend(new_channels_ax)
        ChannelMapperBase.channel_list.extend(new_channels_hq)

        for p in ChannelMapperBase.channel_list:
            if p.canon_list not in ChannelMapperBase.canonical:
                ChannelMapperBase.canonical[p.canon_list] = []
            ChannelMapperBase.canonical[p.canon_list].append(p)
        return True

    b_init = initialize()

    # known particles table with
    # helicity dof's and colour dof's (0 - singlet, 1 - fundamental, 2 - adjoint)
    known = {
        21: (2, 2),
        1: (2, 1),
        2: (2, 1),
        3: (2, 1),
        4: (2, 1),
        5: (2, 1),
        # 6 : (2,1),  # skip the t-quark
        22: (2, 0),
        25: (1, 0),
        11: (2, 0),
        12: (2, 0),
        13: (2, 0),
        14: (2, 0),
        15: (2, 0),
        16: (2, 0),
    }

    PROC_INFO_W = 1 << 0
    PROC_INFO_H = 1 << 1
    PROC_INFO_AA = 1 << 2

    fact = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]  # n!

    proctbl = {}
    init = False

    class ProcessError(Exception):
        def __init__(self, value):
            Exception.__init__(self, value)

    @staticmethod
    def cross_flavour(fv):
        if fv in [21, 22, 23, 25]:
            return fv
        else:
            return -fv

    @staticmethod
    def reorder(data, order):
        (neworder, newdata) = list(zip(*sorted(zip(list(map(abs, order)), data))))
        return newdata

    @staticmethod
    def get_colour_dof(njetopt, ctype):
        if ctype == 0:
            return 1
        elif ctype == 1:
            return njetopt.sun_colour
        elif ctype == 2:
            return njetopt.sun_colour * njetopt.sun_colour - 1

    @staticmethod
    def get_property(propdict, procnum):
        if procnum in propdict:
            return propdict[procnum]
        else:
            return propdict[0]

    @staticmethod
    def set_property(propdict, procnum, value):
        propdict[procnum] = value

    @staticmethod
    def get_alphas_power(ini, fin):
        full = ini + fin
        if not all(abs(p) in Process.known for p in full):
            unknown = [p for p in full if abs(p) not in Process.known]
            raise Process.ProcessError("unknown particle type {}".format(repr(unknown)))
        strong = sum(Process.known[abs(p)][1] != 0 for p in full)
        return strong

    @staticmethod
    def check_params(ini, fin, njetopt, process_idx):
        alphas_power = Process.get_property(njetopt.alphas_power, process_idx)
        correct_alphas_power = Process.get_alphas_power(ini, fin) - 2
        if correct_alphas_power != alphas_power:
            raise Process.ProcessError(
                "wrong AlphasPower %d (try %d)" % (alphas_power, correct_alphas_power)
            )
        alpha_power = Process.get_property(njetopt.alpha_power, process_idx)
        correct_alpha_power = len(ini + fin) - (
            correct_alphas_power + 2
        )  # - (ini + fin).count(25)
        if correct_alpha_power != alpha_power:
            raise Process.ProcessError(
                "wrong AlphaPower %d (try %d)" % (alpha_power, correct_alpha_power)
            )

    @staticmethod
    def extended_match(process_idx, njetopt, channel, chanmatches):
        pn_type = Process.get_property(njetopt.me_type, process_idx)
        if pn_type < NJetOpt.TYPE["mask"]:
            return Process.single_match(channel, chanmatches, "full")
        elif (
            pn_type == NJetOpt.TYPE["leadingpart"]
        ):  # NOTE that works only for loop leadingpart
            try:
                return Process.multiple_match(channel, chanmatches, ["ds"])
            except Process.ProcessError:
                return Process.multiple_match(channel, chanmatches, ["lc"])
        elif (
            pn_type == NJetOpt.TYPE["subleadingpart"]
        ):  # NOTE that works only for loop subleadingpart
            if njetopt.scheme not in [NJetOpt.SCHEME[s] for s in ["NONE", "ZERO"]]:
                raise Process.ProcessError(
                    "AmplitudeType SubLeadingPart needs IRregularisation NONE or ZERO"
                )
            has_ds = True
            try:
                Process.multiple_match(channel, chanmatches, ["ds"])
            except Process.ProcessError:
                has_ds = False
            if has_ds:
                pn_type = NJetOpt.TYPE["zero"]
                Process.set_property(njetopt.me_type, process_idx, pn_type)
                return Process.single_match(channel, chanmatches, "full")
            else:
                return Process.multiple_match(channel, chanmatches, ["slc"])
        elif pn_type == NJetOpt.TYPE["loopds"]:
            return Process.multiple_match(channel, chanmatches, ["ds", "full"])
        elif pn_type == NJetOpt.TYPE["looplc"]:
            return Process.single_match(channel, chanmatches, "lc")
        elif pn_type == NJetOpt.TYPE["loopslc"]:
            return Process.single_match(channel, chanmatches, "slc")
        elif pn_type == NJetOpt.TYPE["loopax"]:
            return Process.single_match(channel, chanmatches, "ax")
        elif pn_type == NJetOpt.TYPE["loophq"]:
            return Process.single_match(channel, chanmatches, "hq")
        raise KeyError()

    @staticmethod
    def single_match(channel, chanmatches, kind):
        allowedmatches = [cm for cm in chanmatches if cm.kind == kind]
        if len(allowedmatches) == 0:
            raise Process.ProcessError(
                "selected AmplitudeType({}) is not available for process {}".format(
                    kind, repr(channel.canon_list)
                )
            )
        assert len(allowedmatches) == 1
        pn = allowedmatches[0].ch
        po = allowedmatches[0].canon_order
        return pn, po

    @staticmethod
    def multiple_match(channel, chanmatches, kinds):
        allowedmatches = [cm for cm in chanmatches if cm.kind in kinds]
        for match in reversed(allowedmatches):
            pn = match.ch
            po = list(match.canon_order)
            if match.fv_nocross:
                full = list(channel.canon_list)
                order = list(channel.canon_order)
                full, order = list(
                    zip(*Process.reorder(list(zip(full, order)), match.canon_order))
                )
                wrong = [order[nc - 1] < 0 for nc in match.fv_symm].count(True)
                if wrong > len(match.fv_cross):
                    continue
                cross = list(match.fv_cross)
                nocross = list(match.fv_nocross)
                for i, o in enumerate(order):
                    ip = i + 1
                    if ip in cross and o < 0:
                        cross.remove(ip)
                    elif ip in nocross and o > 0:
                        nocross.remove(ip)
                for ip, jp in zip(nocross, cross):
                    i = po.index(ip)
                    j = po.index(jp)
                    po[i], po[j] = po[j], po[i]
            return pn, po
        raise Process.ProcessError(
            "selected AmplitudeType is not available for process {}".format(
                repr(channel.canon_list)
            )
        )

    @staticmethod
    def get_flags(channel):
        flags = 0
        lst = list(channel.canon_list)
        if (lst.count(12) == 1 and lst.count(-11) == 1) or (
            lst.count(-12) == 1 and lst.count(11) == 1
        ):
            flags |= Process.PROC_INFO_W
        if lst.count(25) == 1:
            flags |= Process.PROC_INFO_H
        if lst.count(22) == 2:
            flags |= Process.PROC_INFO_AA

        return flags

    @staticmethod
    def get_process(ini, fin, njetopt, process_idx):
        Process.check_params(ini, fin, njetopt, process_idx)
        full = ini + fin

        avg_helic = 1
        avg_color = 1
        for p in ini:
            if Process.get_property(njetopt.ini_hel_average, process_idx) != 0:
                avg_helic *= Process.known[abs(p)][0]
            if Process.get_property(njetopt.ini_col_average, process_idx) != 0:
                avg_color *= Process.get_colour_dof(njetopt, Process.known[abs(p)][1])

        thesign = 1
        fullorder = list(range(1, len(full) + 1))

        for i in range(len(ini)):
            fullorder[i] = -fullorder[i]  # invert momentum
            full[i] = Process.cross_flavour(full[i])  # cross flavour

        channel = Channel(full, fullorder)
        full = channel.canon_list
        order = channel.canon_order

        # final state symmetry factor
        if Process.get_property(njetopt.fin_symmetrize, process_idx) != 0:
            symfactors = [Process.fact[fin.count(p)] for p in set(fin)]
            thesign *= reduce(operator.mul, symfactors, 1)

        try:
            chanmatches = Process.canonical[channel.canon_list]
            pn, po = Process.extended_match(process_idx, njetopt, channel, chanmatches)
        except KeyError:
            raise Process.ProcessError(
                "process not available {}".format(repr(channel.canon_list))
            )

        # sort to proc order
        full, order = list(zip(*Process.reorder(list(zip(full, order)), po)))

        # masked process type (born, loop, etc)
        pn_type = (
            Process.get_property(njetopt.me_type, process_idx) % NJetOpt.TYPE["mask"]
        )

        pn_mult = 1  # always 1 (if changed check process_map)

        rfactor = thesign * avg_helic * avg_color
        flags = Process.get_flags(channel)

        return (
            pn_mult,
            "{} {} {} {} ({})".format(
                pn, rfactor, flags, pn_type, " ".join([str(i) for i in order])
            ),
        )

    def __init__(self):
        raise


class NJetOpt:
    TYPE = {
        "zero": 0,
        "loop": 1,
        "tree": 2,
        "born": 2,
        "cctree": 3,
        "ccborn": 3,
        "cctreeij": 4,
        "ccbornij": 4,
        "sctree": 5,
        "scborn": 5,
        "sctreeij": 6,
        "scbornij": 6,
        "cstree": 7,
        "csborn": 7,
        "cstreei": 8,
        "csborni": 8,
        "loopsq": 9,
        "ccloopsq": 10,
        "ccloopsqij": 11,
        "scloopsq": 12,
        "scloopsqij": 13,
        "csloopsq": 14,
        "csloopsqi": 15,
        "mask": 100,
    }
    TYPE.update(
        {
            "loopds": 1000 + TYPE["loop"],
            "looplc": 1100 + TYPE["loop"],
            "loopslc": 1200 + TYPE["loop"],
            "loopax": 1300 + TYPE["loop"],
            "loophq": 1400 + TYPE["loop"],
            "leadingpart": 2000 + TYPE["loop"],
            "subleadingpart": 2100 + TYPE["loop"],
        }
    )

    SCHEME = {
        "NONE": -1,  # same as unrenormalized FDH (ignores renormalization)
        "FDH": 0,
        "DRED": 0,  # DRED is assumed equal to FDH
        "CDR": 1,
        "ZERO": 2,
    }

    @staticmethod
    def is_on(val):
        lval = val.lower()
        return lval in ["yes", "true"]

    @staticmethod
    def is_off(val):
        lval = val.lower()
        return lval in ["no", "false"]

    MODE_ADD_COUPLINGS = 1 << 0
    MODE_ENABLE_VC = 1 << 1
    MODE_REFINE_DBL_MOM = 1 << 2
    MODE_OMIT_16PISQ = 1 << 3
    MODE_PRINT_STATS = 1 << 4
    MODE_ZERO_HAS_TREE = 1 << 5
    MODE_ZERO_IS_POSITIVE = 1 << 6
    MODE_TWO_COUPLINGS = 1 << 7
    MODE_MAP_CHANNELS = 1 << 8
    MODE_DEFAULT = MODE_ADD_COUPLINGS | MODE_ENABLE_VC

    def mode_enable(self, opt):
        self.opmode = self.opmode | opt

    def mode_disable(self, opt):
        self.opmode = self.opmode & (~opt)

    def mode_check(self, opt):
        return bool(self.opmode & opt)

    def opmodeopt(mode):
        def deco(fn):
            def wrap(self, val):
                ok = fn(self, val)
                if NJetOpt.is_on(val):
                    self.mode_enable(mode)
                elif NJetOpt.is_off(val):
                    self.mode_disable(mode)
                else:
                    raise NJetOpt.OptValueError("try yes, no")
                return ok

            return wrap

        return deco

    class OptionError(Exception):
        def __init__(self, value, reason=""):
            Exception.__init__(self, value)
            self.reason = reason

    class OptValueError(OptionError):
        def __init__(self, value, reason="invalid value"):
            NJetOpt.OptionError.__init__(self, value, reason)

    class OptMissingError(OptionError):
        def __init__(self, value, reason="unsupported"):
            NJetOpt.OptionError.__init__(self, value, reason)

    def localopt(fn):
        def wrap(*args, **kwargs):
            if "procnum" in kwargs:
                wrap.procnum = kwargs["procnum"]
            return fn(*args)

        wrap.local = True
        return wrap

    def globalopt(fn):
        def wrap(*args, **kwargs):
            return fn(*args)

        wrap.local = False
        return wrap

    def msgopt(msg):
        def deco(fn):
            def wrap(*args, **kwargs):
                ret = fn(*args, **kwargs)
                if ret.find("#") == -1:
                    ret += " #"
                ret += " " + msg
                return ret

            return wrap

        return deco

    obsoleteopt = msgopt("obsolete")
    invalidopt = msgopt("non-standard")

    @globalopt
    @opmodeopt(mode=MODE_REFINE_DBL_MOM)
    def NJetRefineMomenta(self, val):
        return "OK"

    @globalopt
    @opmodeopt(mode=MODE_ENABLE_VC)
    def NJetVectorClass(self, val):
        return "OK"

    @globalopt
    @opmodeopt(mode=MODE_OMIT_16PISQ)
    def NJetOmit16PiSq(self, val):
        return "OK"

    @globalopt
    @opmodeopt(mode=MODE_PRINT_STATS)
    def NJetPrintStats(self, val):
        return "OK"

    @globalopt
    @opmodeopt(mode=MODE_ZERO_HAS_TREE)
    def NJetZeroHasTree(self, val):
        return "OK"

    @globalopt
    @opmodeopt(mode=MODE_ZERO_IS_POSITIVE)
    def NJetZeroIsPositive(self, val):
        return "OK"

    @globalopt
    @opmodeopt(mode=MODE_MAP_CHANNELS)
    def NJetMapChannels(self, val):
        return "OK"

    @globalopt
    @opmodeopt(mode=MODE_TWO_COUPLINGS)
    def BLHA1TwoCouplings(self, val):
        return "OK"

    @globalopt
    def NJetMultiPrec(self, sval):
        try:
            val = int(sval)
            assert val in [0, 1, 2]
        except ValueError or AssertionError:
            raise NJetOpt.OptValueError("try 0 - sd, 1 - sd+dd, 2 - sd+dd+qd")
        self.multi_prec = val
        return "OK"

    @globalopt
    def NJetSwitchAcc(self, sval):
        return self.Precision(sval)

    @globalopt
    def Precision(self, sval):
        try:
            val = float(sval)
            assert 1 > val > 0
        except ValueError or AssertionError:
            raise NJetOpt.OptValueError("try a positive real number less than 1")
        self.switch_accuracy = val
        return "OK"

    @globalopt
    def NJetExtraCheckAcc(self, sval):
        try:
            val = float(sval)
            assert 1 > val > 0
        except ValueError or AssertionError:
            raise NJetOpt.OptValueError("try a positive real number less than 1")
        self.extra_accuracy = val
        return "OK"

    @globalopt
    def NJetReturnAccuracy(self, sval):
        try:
            if sval == "no":
                val = 0
            elif sval == "yes":
                val = 2
            else:
                val = int(sval)
            assert val in [0, 1, 2]
        except ValueError or AssertionError:
            raise NJetOpt.OptValueError("try 0 - no, 1 - when available, 2 - always")
        self.return_accuracy = val
        return "OK"

    @globalopt
    @obsoleteopt
    def OperationMode(self, val):
        if val == "CouplingsStrippedOff":
            self.mode_disable(NJetOpt.MODE_ADD_COUPLINGS)
        else:
            raise NJetOpt.OptValueError("try CouplingsStrippedOff")
        return "OK"

    @globalopt
    def IRregularisation(self, val):
        val = val.upper()
        try:
            self.scheme = NJetOpt.SCHEME[val]
        except KeyError:
            raise NJetOpt.OptValueError("try CDR, FDH, DRED, NONE, ZERO")
        return "OK"

    @globalopt
    def NJetRenormalize(self, val):
        if NJetOpt.is_on(val):
            self.renormalize = 1
        elif NJetOpt.is_off(val):
            self.renormalize = 0
        else:
            raise NJetOpt.OptValueError("try yes, no")
        return "OK"

    @globalopt
    def NJetNc(self, sval):
        try:
            val = float(sval)
            assert val > 0
        except ValueError or AssertionError:
            raise NJetOpt.OptValueError("try positive number")
        self.sun_colour = val
        return "OK"

    @globalopt
    @invalidopt
    def NJetBottomMass(self, sval):
        try:
            val = float(sval)
            assert val == 0
        except ValueError or AssertionError:
            raise NJetOpt.OptValueError("try 0 (bottom must be massless)")
        return "OK"

    @globalopt
    @invalidopt
    def NJetTopMass(self, sval):
        try:
            val = float(sval)
            assert val > 10000
        except ValueError or AssertionError:
            raise NJetOpt.OptValueError("1e10 (top is assumed to be infinitely heavy)")
        return "OK"

    @globalopt
    def SetParameter(self, val):
        pname, pval = val.lower().split(" ", 1)
        pval = pval.strip(" ")
        if pname in [
            "sw2",  # sin^2 \theta
            "mass(23)",
            "width(23)",  # Z_0
            "mass(24)",
            "width(24)",  # W^+
            "mass(25)",
            "width(25)",  # H
            "alpha",
            "alphas",
            "qcd(hqmass)",  # heavy quark loop mass
            "qcd(nf)",  # number of light flavours
        ]:
            okmsg = ""
        elif re.match(r"mass\(\d+\)|width\(\d+\)", pname):
            okmsg = " # ignored"
        else:
            raise NJetOpt.OptValueError("try reading the manual")

        try:
            pval = float(pval)
        except ValueError:
            raise NJetOpt.OptValueError("expected real value")
        return "OK" + okmsg

    @localopt
    def MCSymmetrizeFinal(self, val):
        procnum = NJetOpt.MCSymmetrizeFinal.procnum
        if NJetOpt.is_on(val):
            self.fin_symmetrize[procnum] = 1
        elif NJetOpt.is_off(val):
            self.fin_symmetrize[procnum] = 0
        else:
            raise NJetOpt.OptValueError("try yes, no")
        return "OK"

    @localopt
    def HelAvgInitial(self, val):
        procnum = NJetOpt.HelAvgInitial.procnum
        if NJetOpt.is_on(val):
            self.ini_hel_average[procnum] = 1
        elif NJetOpt.is_off(val):
            self.ini_hel_average[procnum] = 0
        else:
            raise NJetOpt.OptValueError("try yes, no")
        return "OK"

    @localopt
    def ColAvgInitial(self, val):
        procnum = NJetOpt.ColAvgInitial.procnum
        if NJetOpt.is_on(val):
            self.ini_col_average[procnum] = 1
        elif NJetOpt.is_off(val):
            self.ini_col_average[procnum] = 0
        else:
            raise NJetOpt.OptValueError("try yes, no")
        return "OK"

    @localopt
    def CouplingPower(self, val):
        try:
            cpl, power = val.replace("\t", " ").split(" ")
            cpl = cpl.upper()
            power = power.strip(" ")
            assert cpl in ["QCD", "QED"]
            if cpl == "QCD":
                return self.AlphasPower(power)
            elif cpl == "QED":
                return self.AlphaPower(power)
        except AssertionError:
            raise NJetOpt.OptValueError("try QCD, QED")

    @localopt
    def AlphasPower(self, val):
        procnum = NJetOpt.AlphasPower.procnum
        try:
            val = int(val)
            assert val in [0, 1, 2, 3, 4, 5]
            self.alphas_power[procnum] = val
        except ValueError or AssertionError:
            raise NJetOpt.OptValueError("try 0, 1, 2, 3, 4, 5")
        return "OK"

    @localopt
    def AlphaPower(self, val):
        procnum = NJetOpt.AlphaPower.procnum
        try:
            val = int(val)
            assert val in [0, 1, 2]
            self.alpha_power[procnum] = val
        except ValueError or AssertionError:
            raise NJetOpt.OptValueError("try 0, 1, 2")
        return "OK"

    @localopt
    @msgopt("obsolete option, use AmplitudeType")
    def NJetType(self, val):
        procnum = NJetOpt.NJetType.procnum
        try:
            if val.count("-") == 0:
                if val.count(".") == 1:
                    procnum, val = val.split(".")
                return self.AmplitudeType(val, procnum=int(procnum))
        except ValueError:
            pass
        raise NJetOpt.OptMissingError("obsolete option, use AmplitudeType")

    @localopt
    def AmplitudeType(self, val):
        procnum = NJetOpt.AmplitudeType.procnum
        try:
            self.me_type[procnum] = NJetOpt.TYPE[val.lower()]
        except (ValueError, KeyError):
            raise NJetOpt.OptValueError(
                "try loop, tree, cctree, cstree, sctree,"
                " leadingpart, subleadingpart, loopsq (more in the manual)"
            )
        return "OK"

    def __init__(self):
        # local settings (e.g. for Process parsing)
        self.fin_symmetrize = {0: 1}
        self.ini_hel_average = {0: 1}
        self.ini_col_average = {0: 1}
        self.alphas_power = {0: 0}
        self.alpha_power = {0: 0}
        self.me_type = {0: NJetOpt.TYPE["loop"]}
        # global settings (to be written in contract file)
        self.multi_prec = 1
        self.switch_accuracy = 1e-5
        self.extra_accuracy = 0.01
        self.return_accuracy = 0
        self.opmode = NJetOpt.MODE_DEFAULT
        self.scheme = 1
        self.renormalize = 1
        self.sun_colour = 3

    def __str__(self):
        return " ".join(
            map(
                str,
                [
                    FORMAT_VERSION,
                    self.multi_prec,
                    self.switch_accuracy,
                    self.extra_accuracy,
                    self.return_accuracy,
                    self.opmode,
                    self.scheme,
                    self.renormalize,
                    self.sun_colour,
                ],
            )
        )


class ListParam:
    def __init__(
        self,
        vals=None,
        okmsg="OK",
        errmsg="",
        local=False,
        ignored=False,
        obsolete=False,
        invalid=False,
        hint=None,
    ):
        self.vals = vals
        self.okmsg = okmsg
        self.errmsg = errmsg
        self.local = local
        self.ignored = ignored
        self.obsolete = obsolete
        self.invalid = invalid
        self.hint = hint

    def getokmsg(self, val):
        okmsg = self.okmsg
        okcomment = []
        if self.ignored:
            okcomment.append("ignored")
        if self.obsolete:
            okcomment.append("obsolete")
        if self.invalid:
            okcomment.append("non-standard")
        if self.hint is not None:
            if self.hint.count("%s") == 1:
                okcomment.append(self.hint % val)
            else:
                okcomment.append(self.hint)
        if okcomment:
            okmsg += " # " + ", ".join(okcomment)
        return okmsg

    def __call__(self, opts, val, **kwargs):
        if self.vals is None:
            raise NJetOpt.OptMissingError(str(self.errmsg))
        elif self.vals and val not in self.vals:
            raise NJetOpt.OptValueError(
                "try {}{}".format(", ".join(self.vals), self.errmsg)
            )
        else:
            return self.getokmsg(val)


class LHOrder:
    ST_HEAD = 1
    ST_INIT = 2
    ST_PROC = 3

    settings = {
        # standard options
        "InterfaceVersion": ListParam(["BLHA1", "BLHA2"]),
        "Model": ListParam(["SM", "SMdiag"]),
        "CorrectionType": ListParam(["QCD"]),
        "AmplitudeType": NJetOpt.AmplitudeType,
        "CouplingPower": NJetOpt.CouplingPower,
        "AlphasPower": NJetOpt.AlphasPower,
        "AlphaPower": NJetOpt.AlphaPower,
        "IRregularisation": NJetOpt.IRregularisation,
        "OperationMode": NJetOpt.OperationMode,  # obsolete
        # ignored standard options
        "EWScheme": ListParam([], ignored=True),
        "WidthScheme": ListParam([], ignored=True),
        "MassiveParticleScheme": ListParam(["OnShell"], ignored=True),
        "SubdivideSubprocess": ListParam(["yes", "no"], ignored=True),
        "LightMassiveParticles": ListParam([], ignored=True),
        "MassiveParticles": ListParam([], ignored=True),  # FIXME
        "ExcludedParticles": ListParam([], ignored=True),  # FIXME
        # Extra options
        "SetParameter": NJetOpt.SetParameter,
        "MCSymmetrizeFinal": NJetOpt.MCSymmetrizeFinal,
        "HelAvgInitial": NJetOpt.HelAvgInitial,
        "ColAvgInitial": NJetOpt.ColAvgInitial,
        "Precision": NJetOpt.Precision,
        "TreatUnstable": ListParam([], ignored=True),
        "BLHA1TwoCouplings": NJetOpt.BLHA1TwoCouplings,
        "NJetVectorClass": NJetOpt.NJetVectorClass,
        "NJetMultiPrec": NJetOpt.NJetMultiPrec,
        "NJetSwitchAcc": NJetOpt.NJetSwitchAcc,
        "NJetExtraCheckAcc": NJetOpt.NJetExtraCheckAcc,
        "NJetReturnAccuracy": NJetOpt.NJetReturnAccuracy,
        "NJetRenormalize": NJetOpt.NJetRenormalize,
        "NJetRefineMomenta": NJetOpt.NJetRefineMomenta,
        "NJetOmit16PiSq": NJetOpt.NJetOmit16PiSq,
        "NJetPrintStats": NJetOpt.NJetPrintStats,
        "NJetZeroHasTree": NJetOpt.NJetZeroHasTree,
        "NJetZeroIsPositive": NJetOpt.NJetZeroIsPositive,
        "NJetMapChannels": NJetOpt.NJetMapChannels,
        "NJetNc": NJetOpt.NJetNc,
        # obsolete and non-standard
        "MatrixElementSquareType": ListParam(["CHsummed"], obsolete=True),
        "ResonanceTreatment": ListParam([], ignored=True, obsolete=True),
        "SuccessiveMultiplicities": ListParam([], ignored=True, obsolete=True),
        "EWRenormalisationScheme": ListParam([], ignored=True, obsolete=True),
        "NJetType": NJetOpt.NJetType,
        "Z_mass": ListParam(
            [], ignored=True, invalid=True, hint="try SetParameter mass(23) %s"
        ),
        "Z_width": ListParam(
            [], ignored=True, invalid=True, hint="try SetParameter width(23) %s",
        ),
        "W_mass": ListParam(
            [], ignored=True, invalid=True, hint="try SetParameter mass(24) %s"
        ),
        "W_width": ListParam(
            [], ignored=True, invalid=True, hint="try SetParameter width(24) %s",
        ),
        "H_mass": ListParam([], ignored=True, invalid=True),
        "H_width": ListParam([], ignored=True, invalid=True),
        "bottom_mass": NJetOpt.NJetBottomMass,  # invalid
        "bottom_width": ListParam([], ignored=True, invalid=True),
        "top_mass": NJetOpt.NJetTopMass,  # invalid
        "top_width": ListParam([], ignored=True, invalid=True),
        "sin_th_2": ListParam(
            [], ignored=True, invalid=True, hint="try SetParameter sw2 %s"
        ),
        "sin2_thetaW": ListParam(
            [], ignored=True, invalid=True, hint="try SetParameter sw2 %s"
        ),
        "csin2_thetaW": ListParam(
            [], ignored=True, invalid=True, hint="try SetParameter sw2 %s"
        ),
        "NJetNf": ListParam(
            [], okmsg="Error:", obsolete=True, hint="try SetParameter qcd(Nf) %s",
        ),
        "NJetHeavyQuarkMass": ListParam(
            [], okmsg="Error:", obsolete=True, hint="try SetParameter qcd(HQmass) %s",
        ),
    }

    def add_comment(self, state, s):
        s = s.lstrip()
        if state == self.ST_HEAD:
            self.header.append(s)
        elif state == self.ST_INIT:
            self.init.append(s)
        elif state == self.ST_PROC:
            self.init.append(s)

    def add_setting(self, extra, proc, name, value, comment, local=False):
        self.private.local = local
        ordername = " ".join(s for s in [extra, proc, name] if s)
        procnum = 0
        if proc:
            procnum = int(proc.split(" ")[1])
        if not comment:
            comment = ""
        try:
            s = LHOrder.settings[name]
            if (proc or local) and not s.local:
                self.init.append(
                    "{} {} | Error: global options cannot apply to subset of processes{}".format(
                        ordername, value, comment
                    )
                )
            elif proc and procnum < 1:
                self.init.append(
                    "{} {} | Error: process numbers start from 1{}".format(
                        ordername, value, comment
                    )
                )
            elif proc and procnum < self.process_idx:
                self.init.append(
                    "{} {} | Error: process {} options cannot be changed after its declaration{}".format(
                        ordername, value, procnum, comment
                    )
                )
            else:
                try:
                    status = s(self.private, value, procnum=procnum)
                    self.init.append(
                        "{} {} | {}{}".format(ordername, value, status, comment)
                    )
                except NJetOpt.OptionError as err:
                    self.init.append(
                        "{} {} | Error: {}{}".format(
                            ordername, value, err.reason, comment
                        )
                    )
                    if str(err):
                        self.init.append("# {}".format(err))
        except KeyError:
            self.init.append(
                "{} {} | Error: unknown option{}".format(ordername, value, comment)
            )
            import difflib

            similar = difflib.get_close_matches(name, list(LHOrder.settings.keys()))
            if similar:
                self.init.append(
                    "# did you mean {}?".format(" or ".join(map(str, similar)))
                )

    def add_private_settings(self):
        self.init.insert(0, "# " + str(self.private))

    def add_process(self, ini, fin, comment):
        ini = list(map(int, ini.split()))
        fin = list(map(int, fin.split()))
        if not comment:
            comment = ""
        try:
            procmult, procstr = Process.get_process(
                ini, fin, self.private, self.process_idx
            )
            if not (
                self.private.mode_check(NJetOpt.MODE_MAP_CHANNELS)
                and procstr in self.process_map
            ):
                self.process_map[procstr] = self.process_mcnum
                self.process_mcnum += procmult
            mn = self.process_map[procstr]
            procidxs = " ".join(str(i) for i in range(mn, mn + procmult))
            self.init.append(
                "{} -> {} | 1 {} # {}{}".format(
                    " ".join(map(str, ini)),
                    " ".join(map(str, fin)),
                    procidxs,
                    procstr,
                    comment,
                )
            )
        except Process.ProcessError as err:
            self.init.append(
                "{} -> {} | Error: {}{}".format(
                    " ".join(map(str, ini)), " ".join(map(str, fin)), err, comment,
                )
            )
        self.process_idx += 1

    @staticmethod
    def clean_file(f):
        output = StringIO()
        state = 0
        for line in f:
            try:
                cont0 = re.match((r"^%s" % NJETBANNER[:-1]).encode(), line)
            except TypeError:
                cont0 = re.match(
                    (r"^%s" % NJETBANNER[:-1]).encode(), line.encode()
                )  # python 3
            if cont0:
                continue
            try:
                cont1 = re.match(NJETSIGNED_PAT.encode(), line)
            except TypeError:
                cont1 = re.match(NJETSIGNED_PAT.encode(), line.encode())  # python3
            if state == 0 and cont1:
                state = 1
                continue
            if state == 1:
                try:
                    cont2 = re.match(r"^# \d+ \d+ ".encode(), line)
                except TypeError:
                    cont2 = re.match(r"^# \d+ \d+ ".encode(), line.encode())  # python3
                if cont2:
                    state = 2
                    continue
                else:
                    state = 0
                    continue
            if state == 2:
                try:
                    line = re.sub(r"^([^|#]+) \|.*".encode(), r"\1".encode(), line)
                except TypeError:
                    line = re.sub(
                        r"^([^|#]+) \|.*".encode(), r"\1".encode(), line.encode(),
                    )  # python3
            try:
                output.write(line.decode())
            except AttributeError:
                output.write(line)  # python3
        f.close()
        output.seek(0)
        return output

    def fromfile(self, f):
        i = 0
        state = self.ST_HEAD
        ignore_pat = re.compile(r"^\s*$|%s" % NJETSIGNED_PAT)
        header_pat = re.compile(r"^\s*#")
        param_pat = re.compile(
            r"(?i)^(?P<extra>\s*Extra)?\s*"
            r"(?P<proc>\s*Process\s+\d+)?\s*"
            r"(?P<name>\w+)\s+"
            r"(?P<value>[\-\w. ()]+?)\s*?"
            r"(?P<comment>\s*#.*?)?$"
        )
        process_pat = re.compile(
            r"^\s*(-?\d+(?:\s+-?\d+)?)\s*->\s*(-?\d+(?:\s+-?\d+)+)\s*(#.*)?$"
        )

        for line_tmp in f:
            try:
                line = line_tmp.decode()
            except AttributeError:
                line = line_tmp
            i += 1
            if ignore_pat.match(line):
                continue
            elif header_pat.match(line):
                self.add_comment(state, line.rstrip("\r\n"))
                continue
            elif state == self.ST_HEAD:
                state = self.ST_INIT
            if state == self.ST_INIT:
                m = param_pat.match(line)
                if m:
                    # self.add_setting(*m.group('extra', 'proc', 'name', 'value', 'comm'))
                    self.add_setting(**m.groupdict())
                else:
                    state = self.ST_PROC
            if state == self.ST_PROC:
                m = process_pat.match(line)
                if m:
                    self.add_process(*m.group(1, 2, 3))
                else:
                    m = param_pat.match(line)
                    if m:
                        self.add_setting(local=True, **m.groupdict())
                    else:
                        print("Error: invalid input on line {}:\n{}".format(i, line))
                        sys.exit(2)
        if state != self.ST_PROC:
            print("Error: no processes in the file EOF")
            sys.exit(2)
        self.add_private_settings()
        f.close()

    def __init__(self, f=None):
        self.header = []
        self.init = []
        self.process_map = {}
        self.process_idx = 1
        self.process_mcnum = 1
        self.private = NJetOpt()
        if f:
            self.fromfile(f)

    def strlist(self):
        sl = []
        sl.extend([s + "\n" for s in self.init])
        return sl

    @staticmethod
    def check(s):
        m = 65521
        a = 1
        b = 0
        for c in s:
            a = (a + ord(c)) % m
            b = (b + a) % m
        return (b << 16) | a

    def sign(self, sl):
        skip = re.compile(r"^\s*$|^\s*#.*$|^[^#]+\| Error:.*$")
        try:
            msg = sl[0].decode() + "".join(
                [s.decode() for s in sl if not skip.match(s.decode())]
            )
        except AttributeError:
            msg = sl[0] + "".join([s for s in sl if not skip.match(s)])
        return self.check(msg)

    def output(self, f=None):
        if f:
            try:
                f.write("".join([s + "\n" for s in self.header]).encode())
                sl = self.strlist()
                f.write(NJETBANNER.encode())
                f.write((NJETSIGNED.format(self.sign(sl)).encode()))
                f.write("".join(sl).encode())
            except TypeError:
                f.write("".join([s + "\n" for s in self.header]))
                sl = self.strlist()
                f.write(NJETBANNER)
                f.write((NJETSIGNED.format(self.sign(sl))))
                f.write("".join(sl))
            if not isinstance(f, StringIO):
                f.close()


def dump(params, silent=False):
    pidx = -999
    s = []
    for name, idx in sorted(list(Channel.name2id.items()), key=lambda x: x[1]):
        if idx == pidx + 1 and (silent or idx % 10 != 0):
            s.append("E" + name)
        else:
            s.append("E{}={}".format(name, idx))
        pidx = idx
    s.append("ECHANNELS")
    ss = ",".join(s)
    print("enum NAMES {")
    print(re.sub(r"(.{60}.*?,)", r"\1\n", ss))
    print("};")


def sign(params):
    f = params.get_ifile()
    if params.update:
        f = LHOrder.clean_file(f)
    order = LHOrder(f)
    order.output(params.get_ofile())


def repair(params):
    verify(params, repair_=True)


def verify(params, repair_=False):
    f = params.get_ifile()
    pre = []
    sl = []
    val = -1
    for s in f:
        if val < 0:
            pre.append(s.decode())
            m = re.match((NJETSIGNED_PAT + r"(\d+)").encode(), s)
            if m:
                val = int(m.group(1))
        elif val > 0:
            sl.append(s.decode())
    f.close()
    if val < 0:
        print("Error: not NJet contract file")
        return
    order = LHOrder()
    comp = order.sign(sl)
    if val == comp:
        print("OK: {} == {}".format(val, comp))
        if repair_:
            print("No need to repair")
    elif repair_:
        f = params.get_ofile()
        pre[-1] = NJETSIGNED.format(comp)
        f.write("".join(pre).encode())
        f.write("".join(sl).encode())
        f.close()
    else:
        print("FAIL: {} != {}".format(val, comp))


class Params:
    def __init__(self):
        meta_in = "INPUT_FILE"
        meta_out = "OUTPUT_FILE"
        def_in = "OLE_order.lh"
        def_out = "OLE_contract.lh"
        parser = argparse.ArgumentParser(
            description="""
            Process BLHA order file {} and generate contract file {}.
            By default reads from {} and writes to {}.
            Customise filenames with e.g.
            `njet.py my_order.lh -o my_contract.lh`.
            Additional functionality described in optional arguments.
            """.format(
                meta_in, meta_out, def_in, def_out
            )
        )

        parser.add_argument(
            "input", metavar=meta_in, nargs="?", default=argparse.SUPPRESS
        )
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "-s",
            "--sign",
            action="store_false",
            help="""
            [DEPRECATED] sign order file {} (default {}); default behaviour
            """.format(
                meta_in, def_in
            ),
        )
        group.add_argument(
            "-v",
            "--verify",
            action="store_true",
            help="verify contract file {} (default {})".format(meta_in, def_out),
        )
        group.add_argument(
            "-r",
            "--repair",
            action="store_true",
            help="repair contract file {} (default {})".format(meta_in, def_out),
        )
        group.add_argument(
            "-u",
            "--update",
            action="store_true",
            help="""
            update contract file {} (default {})
            """.format(
                meta_in, def_out
            ),
        )
        group.add_argument(
            "-d",
            "--dump",
            action="store_true",
            help="""
                            development option: print channels;
                            update interface with
                            `njet.py -d > njet/chsums/NJetChannels.h`
                            """,
        )
        parser.add_argument(
            "-o",
            "--output",
            type=str,
            default=def_out,
            metavar=meta_out,
            help="output to {} instead of OLE_contract.lh".format(meta_out),
        )
        parser.add_argument(
            "--version",
            action="version",
            version="""
            %(prog)s BLHA interface format version {}
            """.format(
                FORMAT_VERSION
            ),
        )

        args = parser.parse_args()

        if "input" in args:
            self.iname = args.input
        else:
            if any([args.verify, args.repair, args.update]):
                self.iname = def_out
            else:
                self.iname = def_in

        self.oname = args.output

        self.update = False

        if args.verify:
            self.action = "verify"
        elif args.repair:
            self.action = "repair"
        elif args.update:
            self.update = True
            self.action = "sign"
        elif args.dump:
            self.action = "dump"
        else:
            self.action = "sign"

        if not (args.dump or os.path.exists(self.iname)):
            print("Error: cannot find input file: {}".format(self.iname))
            sys.exit(2)

    def get_ifile(self):
        return open(self.iname, "rb")

    def get_ofile(self):
        return open(self.oname, "wb")


def main():
    param = Params()
    globals()[param.action](param)


if __name__ == "__main__":
    main()

# ============================================================================

if __name__ != "__main__":
    try:
        import ctypes
        from ctypes import c_int, c_double, c_char_p, POINTER
    except ImportError as e:
        print(e)
        sys.exit(2)


class OLP:
    init = False

    order = None
    contract = None

    libnjet = None

    @staticmethod
    def OLP_Start(contract, generate=True, libnjet="libnjet3.so"):
        if not OLP.libnjet:
            try:
                OLP.libnjet = ctypes.CDLL(libnjet)
                OLP.libnjet.OLP_Start.restype = None
                OLP.libnjet.OLP_Start.argtypes = [
                    c_char_p,
                    ctypes.POINTER(c_int),
                ]
                OLP.libnjet.OLP_EvalSubProcess.restype = None
                OLP.libnjet.OLP_EvalSubProcess.argtypes = [
                    c_int,
                    POINTER(c_double),
                    c_double,
                    POINTER(c_double),
                    POINTER(c_double),
                ]
            except OSError as err:
                print(err)
                sys.exit(2)
        if os.path.exists(contract):
            f = open(contract)
            contract = f.read()
            f.close()
        if not re.match(NJETSIGNED_PAT, contract) or generate:
            orderio = LHOrder.clean_file(StringIO(contract))
            OLP.order = LHOrder(orderio)
            contractio = StringIO()
            OLP.order.output(contractio)
            contract = contractio.getvalue()
        status = c_int(-1)
        OLP.libnjet.OLP_Start(c_char_p(contract.encode()), status)
        if status.value != 0:
            OLP.init = True
            OLP.contract = contract
        else:
            OLP.init = False
            err = False
            for line in contract.split("\n"):
                if line.find("Error") >= 0:
                    print(line)
                    err = True
                elif err:
                    print(line)
                    err = False
        return OLP.init

    @staticmethod
    def OLP_EvalSubProcess(mcn, pparr, mur=1.0, alphas=1.0, alpha=1.0, retlen=7):
        if not OLP.init:
            raise RuntimeError("NJet not initialized")
        cpparr = OLP.cMomenta(pparr)
        cmur = c_double(mur)
        ccpl = (c_double * 2)(alphas, alpha)
        crval = (c_double * retlen)()
        OLP.libnjet.OLP_EvalSubProcess(mcn, cpparr, cmur, ccpl, crval)
        return [crval[i] for i in range(retlen)]
    
    # Note Contract::MODE_TWO_COUPLINGS set to true is equivalent to set_alpha=True
    # If Contract::MODE_TWO_COUPLINGS is False, need to manually turn off set_alpha
    @staticmethod
    def OLP_SetParameter(alpha=1., alphas=1., set_alpha = True):
        if not OLP.init:
            raise RuntimeError("NJet not initialized")
        calphas = c_double(alphas)
        crstatus = c_int()
        cimpart = c_double(0.)
        cs_string = c_char_p("alphas")
        OLP.libnjet.OLP_SetParameter(cs_string, byref(calphas), byref(cimpart), byref(crstatus))
        cpass = c_int(1)
        if crstatus == cpass:
            print ('alphas set correctly')
        if set_alpha == True:
            calpha = c_double(alpha)
            c_string = c_char_p("alpha")
            crstatus_alpha = c_int()
            OLP.libnjet.OLP_SetParameter(c_string, byref(calpha), byref(cimpart), byref(crstatus_alpha))
            if crstatus_alpha == 1:
                print ('alpha set correctly')
            

    # note this needs to have OLP_SetParameter run with it in order to work
    @staticmethod
    def OLP_EvalSubProcess2(mcn, pparr, mur=1.,retlen=7, acc=0.):
        if not OLP.init:
            raise RuntimeError("NJet not initialized")
        cpparr = OLP.cMomenta(pparr)
        cmur = c_double(mur)
        crval = (c_double * retlen)()
        cacc = c_double(acc)
        cmcn = c_int(mcn)
        OLP.libnjet.OLP_EvalSubProcess2(byref(cmcn), cpparr, byref(cmur), crval, byref(cacc))
        return [crval[i] for i in range(retlen)]


    @staticmethod
    def cMomenta(pparr):
        pp = None
        if pparr:
            legs = len(pparr)
            pp = (c_double * (5 * legs))()
            for i in range(legs):
                ppi = pparr[i]
                pp[i * 5 + 4] = 0.0
                for j in range(len(ppi)):
                    pp[i * 5 + j] = ppi[j]
        return pp


def OLP_Start(*args, **kwargs):
    return OLP.OLP_Start(*args, **kwargs)


def OLP_EvalSubProcess(*args, **kwargs):
    return OLP_EvalSubProcess(*args, **kwargs)

def OLP_SetParameter(*args, **kwargs):
    return OLP_SetParameter(*args, **kwargs)

def OLP_EvalSubProcess2(*args, **kwargs):
    return OLP_EvalSubProcess2(*args, **kwargs)
