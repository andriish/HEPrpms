diff --git a/include/recola.h b/include/recola.h
index db6f2f5..aacc916 100644
--- a/include/recola.h
+++ b/include/recola.h
@@ -163,6 +163,10 @@ void RCLMOD(input,set_renoscheme)
 // get_renoscheme_rcl -> wrapper
 void RCLMOD(input,set_resonant_particle)
      (const char*,long int);
+void RCLMOD(input,set_internal_projection)
+     (const int*,const int*,const int*);
+void RCLMOD(input,update_internal_projection)
+     (const int*,const int*,const int*);
 void RCLMOD(input,set_quarkline)
      (const int*,const int*,const int*);
 void RCLMOD(input,reset_vertices)
@@ -173,6 +177,10 @@ void RCLMOD(input,reset_ctcouplings)
      ();
 void RCLMOD(input,print_collier_statistics)
      ();
+void RCLMOD(input,initialise_particles_rcl)
+     ();
+void RCLMOD(input,clear_particles_rcl)
+     ();
 
 // additional stuff, only used in combination with rept1l
 void RCLMOD(input,set_compute_selfenergy)
@@ -957,6 +965,16 @@ ivoid set_resonant_particle_rcl
 {
   RCLMOD(input,set_resonant_particle)(p, strlen(p));
 }
+ivoid set_internal_projection_rcl
+            (int npr, int v, int p)
+{
+  RCLMOD(input,set_internal_projection)(&npr,&v,&p);
+}
+ivoid update_internal_projection_rcl
+            (int npr, int v, int p)
+{
+  RCLMOD(input,update_internal_projection)(&npr,&v,&p);
+}
 ivoid set_quarkline_rcl
             (int npr, int q1, int q2)
 {
@@ -978,6 +996,14 @@ ivoid print_collier_statistics_rcl()
 {
   RCLMOD(input,print_collier_statistics)();
 }
+ivoid initialise_particles_rcl()
+{
+  RCLMOD(input,initialise_particles_rcl)();
+}
+ivoid clear_particles_rcl()
+{
+  RCLMOD(input,clear_particles_rcl)();
+}
 
 
 /**********************************************
diff --git a/include/recola.hpp b/include/recola.hpp
index 9cc7047..5789b76 100644
--- a/include/recola.hpp
+++ b/include/recola.hpp
@@ -983,6 +983,16 @@ ivoid set_resonant_particle_rcl
 {
   RCLMOD(input,set_resonant_particle)(pa.c_str(),pa.length());
 }
+ivoid set_internal_projection_rcl
+      (const int npr, const int v, const int p)
+{
+  RCLMOD(input,set_internal_projection)(&npr,&v,&p);
+}
+ivoid update_internal_projection_rcl
+      (const int npr, const int v, const int p)
+{
+  RCLMOD(input,update_internal_projection)(&npr,&v,&p);
+}
 ivoid set_quarkline_rcl
       (const int npr, const int q1, const int q2)
 {
@@ -1008,6 +1018,16 @@ ivoid print_collier_statistics_rcl
 {
   RCLMOD(input,print_collier_statistics)();
 }
+ivoid initialise_particles_rcl
+      ()
+{
+  RCLMOD(input,initialise_particles_rcl)();
+}
+ivoid clear_particles_rcl
+      ()
+{
+  RCLMOD(input,clear_particles_rcl)();
+}
 
 
 /**********************************
diff --git a/src/api/input_rcl.f90 b/src/api/input_rcl.f90
index 004e313..65bc5e6 100644
--- a/src/api/input_rcl.f90
+++ b/src/api/input_rcl.f90
@@ -717,6 +717,23 @@ module input_rcl
 
 !------------------------------------------------------------------------------!
 
+  subroutine initialise_particles_rcl
+    use modelfile, only: is_particle_model_init_mdl,   &
+                      set_particle_model_init_mdl,  &
+                      init_particles_mdl
+
+    if (.not. is_particle_model_init_mdl()) then
+      call init_particles_mdl()
+      call set_particle_model_init_mdl(.true.)
+    end if
+  end subroutine initialise_particles_rcl
+
+  subroutine clear_particles_rcl
+    use modelfile, only: clear_particles_mdl
+
+    call clear_particles_mdl()
+  end subroutine clear_particles_rcl
+
   subroutine switchoff_couplingN_rcl(pan,nmax,xlp_in)
     use modelfile, only: is_particle_model_init_mdl,   &
                          get_particle_id_mdl,          &
@@ -1226,6 +1243,110 @@ module input_rcl
 
   end subroutine set_resonant_particle_rcl
 
+!------------------------------------------------------------------------------!
+
+  subroutine set_internal_projection_rcl (npr,v,p,fp_warning)
+  ! Select polarization of massive intermediate particle.
+  ! Args:
+  !   npr (int): process number
+  !   v (int): particle binary id
+  !   p (int): polarisation state: -1, 0, +1, 3
+  ! Note:\n\
+  !   The internal lines, for which the projection
+  !   is done, need to be on-shell. Usually, the pole-
+  !   approximation is used for that.
+  !   p = 3 can be selected to get the transverse polarization
+  !   contribution, i.e. the add-up left- and right-handed
+  !   polarization contributions.
+  ! Examples:
+  !   External particle are identified by binaries, i.e. in this example
+  !   1 (u), 2 (u~), e+(4), nu_e(8), mu-(16), nu_mu~(32), g(64)
+  !   Define the process:
+  !   >>> call define_process_rcl(1, 'u u~ > e+ nu_e mu- nu_mu~ g', 'LO')
+  !   Set the polarisation of the internal W^+ line:
+  !   >>> call set_internal_projection_rcl(1, 12, -1)
+  !   12 refers to e+ (4) + nu_e (8)
+  !   Set the polarisation of the internal W^- line:
+  !   call set_internal_projection_rcl(1, 48, -1)
+  !   48 refers to mu- (16) + nu_mu~ (32)
+
+    integer, intent(in) :: v, p, npr
+    logical, intent(in), optional :: fp_warning
+    logical :: warning
+    integer             :: pr, legs, vp
+
+    if (present(fp_warning)) then
+      warning = fp_warning
+    else
+      warning = .true.
+    end if
+
+    if (warning) call processes_generated_warning_rcl('set_internal_projection_rcl')
+    call get_pr(npr,'set_internal_projection_rcl',pr)
+
+    legs = prs(pr)%legs
+    ! legs -> lmax = maxval(prs(:)%legs)
+
+    ! polproj stores only projections of the first 2**(legs-1) momenta
+    if (v .ge. 2**(legs-1)) then
+      vp = 2**(legs) - 1 - v
+      ! flip helicity for transversal polarization for opposite
+      ! propagation direction
+      if (abs(p) .eq. 1) then
+        prs(pr)%polproj(vp) = -p
+      else
+        prs(pr)%polproj(vp) = p
+      end if
+    else
+      vp = v
+      prs(pr)%polproj(vp) = p
+    end if
+
+  end subroutine set_internal_projection_rcl
+
+  subroutine update_internal_projection_rcl (npr,v,p)
+  ! Do the same as set_internal_projection_rcl but also update the internally used polprojin array.
+    integer, intent(in) :: v, p, npr
+    integer             :: pr, legs, tlm1, tl, i, j, k
+
+    call warning_rcl('The helicity projection values are changed after first setting them. The Amplitude has to be recalculated.', &
+                     'update_internal_projection_rcl')
+    call get_pr(npr,'update_internal_projection_rcl',pr)
+
+    call set_internal_projection_rcl(npr,v,p,.false.)
+
+    legs = prs(pr)%legs
+
+    ! translate vector polarizations to internal (permutated) ones
+    tlm1 = 2**(legs-1)
+    tl   = 2**legs
+    do i = 1, tlm1-1
+      if (prs(pr)%polproj(i) .ne. nopol) then
+        j = 0
+        do k = 1,legs
+          if (iand(2**(k-1), i) .ne. 0) then
+            j = j + 2**(newleg(k,pr)-1)
+          end if
+        end do
+
+        prs(pr)%polprojin(j) = prs(pr)%polproj(i)
+
+        ! polprojin (used in amplitude_rcl) opposed to polproj stores the
+        ! projections of all the momenta, i.e. 2**(lmax)-1 momenta
+        ! here we enter the case for: p -> -p
+        j  = tl - 1 - j
+
+        ! flip helicity for transversal polarization for opposite
+        ! propagation direction
+        if (abs(prs(pr)%polproj(i)) .eq. 1) then
+          prs(pr)%polprojin(j) = -prs(pr)%polproj(i)
+        else
+          prs(pr)%polprojin(j) = prs(pr)%polproj(i)
+        end if
+      end if
+    end do
+  end subroutine update_internal_projection_rcl
+
 !------------------------------------------------------------------------------!
 
   subroutine set_quarkline_rcl (npr,q1,q2)
diff --git a/src/api/process_definition_rcl.f90 b/src/api/process_definition_rcl.f90
index 2d54f65..2cb70bf 100644
--- a/src/api/process_definition_rcl.f90
+++ b/src/api/process_definition_rcl.f90
@@ -39,6 +39,7 @@ module process_definition_rcl
                             crossprocess,otter_mode
   integer, allocatable   :: pa(:),paT(:),he(:),heT(:),relperm(:)
   integer, allocatable   :: qflow(:), powsel(:,:,:)
+  integer, allocatable   :: polproj(:), polprojin(:)
   character              :: cpr*99,cpr0*99,che*3
   character, allocatable :: cpa(:)*7,cpaT(:)*7
   character(len=10)      :: log_info
@@ -160,6 +161,12 @@ module process_definition_rcl
   allocate(newpr)
   allocate(qflow(le))
   qflow= 0
+
+  allocate(polproj(2**(le-1)-1))
+  polproj   = nopol
+  allocate(polprojin(2**le-1))
+  polprojin = nopol
+
   allocate(powsel(0:4*le+2,nord,0:1))
   powsel= 1
   allocate(relperm(le))
@@ -175,6 +182,8 @@ module process_definition_rcl
                       binRes=binnd(1:nd0),        &
                       parRes=pond(1:nd0),         &
                       qflow=qflow,                &
+                      polproj=polproj,            &
+                      polprojin=polprojin,        &
                       powsel=powsel,              &
                       crosspr=crossprocess,       &
                       relperm=relperm,            &
@@ -183,7 +192,7 @@ module process_definition_rcl
                       otter_mode=otter_mode &
                       )
   call insert_process_def(newpr)
-  deallocate(qflow,powsel,relperm,newpr)
+  deallocate(qflow,powsel,relperm,newpr,polproj,polprojin)
 
   legsMax = maxval(prs(:)%legs)
 
@@ -221,6 +230,8 @@ module process_definition_rcl
         allocate(prsT(i)%binRes(resMax))
         allocate(prsT(i)%parRes(resMax))
         allocate(prsT(i)%qflow(legs))
+        allocate(prsT(i)%polproj(2**(legs-1)-1))
+        allocate(prsT(i)%polprojin(2**legs-1))
         allocate(prsT(i)%powsel(size(prs(i)%powsel,1),nord,0:1))
         prsT(i) = prs(i)
       end do
@@ -234,6 +245,8 @@ module process_definition_rcl
         allocate(prs(i)%binRes(legs))
         allocate(prs(i)%parRes(legs))
         allocate(prs(i)%qflow(legs))
+        allocate(prs(i)%polproj(2**(legs-1)-1))
+        allocate(prs(i)%polprojin(2**legs-1))
         allocate(prs(i)%powsel(size(prsT(i)%powsel,1),nord,0:1))
         prs(i) = prsT(i)
       end do
@@ -247,6 +260,8 @@ module process_definition_rcl
     allocate(prs(prTot)%binRes(legs))
     allocate(prs(prTot)%parRes(legs))
     allocate(prs(prTot)%qflow(legs))
+    allocate(prs(prTot)%polproj(2**(legs-1)-1))
+    allocate(prs(prTot)%polprojin(2**legs-1))
     allocate(prs(prTot)%powsel(size(prsin%powsel,1),nord,0:1))
     prs(prTot) = prsin
 
diff --git a/src/core/amplitude_rcl.f90 b/src/core/amplitude_rcl.f90
index 11b898c..323b1ea 100644
--- a/src/core/amplitude_rcl.f90
+++ b/src/core/amplitude_rcl.f90
@@ -28,8 +28,9 @@ module amplitude_rcl
                        get_coupling_value_mdl,get_order_id_mdl,             &
                        get_particle_type2_mdl,get_recola_base_mdl,          &
                        get_particle_mass_id_mdl,get_particle_name_mdl,      &
-                       is_resonant_particle_id_mdl, &
+                       is_resonant_particle_id_mdl,                         &
                        get_propagator_extension_mdl,get_parameter_mdl,      &
+                       get_particle_type_mdl,get_particle_mass_reg_mdl,     &
                        has_feature_mdl,reset_ctcouplings_mdl
   use tables_rcl, only: levelLeg,firstNumbers,riMax,dzgs
   use collier_interface_rcl, only: InitEvent_cll,GetAccFlag_cll,TNten_cll, &
@@ -59,7 +60,15 @@ module amplitude_rcl
                               matrix2sc(:,:),         &
                               matrix2scm(:,:,:,:),    &
                               matrix2scnlo(:,:)
-
+  integer     :: pid, pidc, wid, polsel
+  real(dp) :: mass_proj
+  complex(dp) :: pol1(0:3), pol1_cv(0:3), &
+                 pol1a(0:3), pol1b(0:3), pol1c(0:3), pol1d(0:3), &
+                 pol1a_cv(0:3), pol1b_cv(0:3), pol1c_cv(0:3), pol1d_cv(0:3), &
+                 contr_tmp(0:3), &
+                 contr_tmpa(0:3), contr_tmpb(0:3), contr_tmpc(0:3), contr_tmpd(0:3)
+  logical     :: massive_vector_boson, goldstone_boson, &
+                 massive_fermion, massive_anti_fermion
 
 #ifdef WITHOTTER
   type iptr
@@ -1037,6 +1046,8 @@ module amplitude_rcl
             m2 = cosm0(s,pr)%m2
             m = cosm0(s,pr)%m
 
+            mass_proj = sqrt(real(m2,kind=dp))
+
             if (defresbin(lout,pr)) then
               width = get_particle_width_mdl(parsm0(s,pr))
               m2p = m2 - cima*width*m
@@ -1175,6 +1186,245 @@ module amplitude_rcl
                              where='compute_amplitude(internal)')
             end select
 
+            ! Polarisation stuff:
+            pid = parsm0(s,pr)  ! particle id
+            ! write(*,*) "pid:       ", pid
+            ! write(*,*) "particle:  ", get_particle_name_mdl(pid)
+
+            massive_vector_boson = trim(get_particle_type_mdl(pid)) .eq. "v" .and. &
+                                   get_particle_mass_reg_mdl(pid) .eq. 3
+            ! get_particle_mass_reg_mdl(pid) = 3 -> massive particle.
+
+            massive_fermion = trim(get_particle_type_mdl(pid)) .eq. "f" .and. &
+                              get_particle_mass_reg_mdl(pid) .eq. 3
+
+            massive_anti_fermion = trim(get_particle_type_mdl(pid)) .eq. "f~" .and. &
+                                   get_particle_mass_reg_mdl(pid) .eq. 3
+
+            goldstone_boson = trim(get_particle_type_mdl(pid)) .eq. "0"
+
+            ! Massive vector bosons
+            if ((prs(prin)%polprojin(lout) .ge. -1) .and. &
+                (prs(prin)%polprojin(lout) .le. 1) .and. &
+                massive_vector_boson) then
+              ! compute polarization for a massive vector boson (3 just a
+              ! dummy W-boson with modified mass)
+              wid = 3
+              call definewp (wid,             &
+                   p(:,lout),                 &
+                   pl(:,lout),                &
+                   mass_proj,                 &
+                   prs(prin)%polprojin(lout), &
+                   pol1)
+              pol1_cv(0)   = pol1(0)
+              pol1_cv(1:3) = -pol1(1:3)
+              contr_tmp = sum(ww0out(:,mo)*pol1_cv(:))*conjg(pol1(:))
+              ww0out(:,mo) = -contr_tmp
+            end if
+
+            ! coherent sum of left- and right-handed polarization vector.
+            if (prs(prin)%polprojin(lout) .eq. 3 .and. massive_vector_boson) then
+              wid = 3
+              call definewp (wid, &
+                   p(:,lout),     &
+                   pl(:,lout),    &
+                   mass_proj,     &
+                   -1,            &
+                   pol1a) !  left pol vec
+              pol1a_cv(0)   = pol1a(0)
+              pol1a_cv(1:3) = -pol1a(1:3)
+              contr_tmpa = sum(ww0out(:,mo)*pol1a_cv(:))*conjg(pol1a(:))
+              call definewp (wid, &
+                   p(:,lout),     &
+                   pl(:,lout),    &
+                   mass_proj,     &
+                   +1,            &
+                   pol1b) ! right pol vec
+              pol1b_cv(0)   = pol1b(0)
+              pol1b_cv(1:3) = -pol1b(1:3)
+              contr_tmpb = sum(ww0out(:,mo)*pol1b_cv(:))*conjg(pol1b(:))
+
+              ww0out(:,mo) = -contr_tmpa -contr_tmpb
+            end if
+
+            ! Unpolarised case, i.e. (prs(prin)%polprojin(lout) .eq. 4): Do nothing and just keep the propagator as it is.
+
+            ! Check start
+            ! Adding up all contributions should give exactly the same result, as not changing the propagator, due to its projector structure.
+            ! The following is therefore a test.
+            if (prs(prin)%polprojin(lout) .eq. 5 .and. massive_vector_boson) then
+              wid = 3
+              call definewp (wid, &
+                   p(:,lout),     &
+                   pl(:,lout),    &
+                   mass_proj,     &
+                   -1,            &
+                  pol1a) !  left pol vec
+              pol1a_cv(0)   = pol1a(0)
+              pol1a_cv(1:3) = -pol1a(1:3)
+              contr_tmpa = sum(ww0out(:,mo)*pol1a_cv(:))*conjg(pol1a(:))
+              call definewp (wid, &
+                   p(:,lout),     &
+                   pl(:,lout),    &
+                   mass_proj,     &
+                   +1,            &
+                  pol1b) ! right pol vec
+              pol1b_cv(0)   = pol1b(0)
+              pol1b_cv(1:3) = -pol1b(1:3)
+              contr_tmpb = sum(ww0out(:,mo)*pol1b_cv(:))*conjg(pol1b(:))
+
+              call definewp (wid, &
+                   p(:,lout),     &
+                   pl(:,lout),    &
+                   mass_proj,     &
+                   0,             &
+                   pol1c) ! longitudinal pol vec
+              pol1c_cv(0)   = pol1c(0)
+              pol1c_cv(1:3) = -pol1c(1:3)
+              contr_tmpc = sum(ww0out(:,mo)*pol1c_cv(:))*conjg(pol1c(:))
+
+              call definewp (wid, &
+                   p(:,lout),     &
+                   pl(:,lout),    &
+                   mass_proj,     &
+                   2,             &
+                   pol1d) ! auxiliary pol vec
+              pol1d_cv(0)   = pol1d(0)
+              pol1d_cv(1:3) = -pol1d(1:3)
+              contr_tmpd = sum(ww0out(:,mo)*pol1d_cv(:))*conjg(pol1d(:))
+
+              ww0out(:,mo) = -contr_tmpa -contr_tmpb -contr_tmpc -contr_tmpd
+            end if
+            ! Check end
+
+            ! Fermion polarization projection
+            if (prs(prin)%polprojin(lout) .ne. nopol .and. &
+              (massive_fermion .or. massive_anti_fermion)) then
+                write(*,*) "Polarizations for fermions are not supported jet."
+                stop 9
+            end if
+              ! ! Fermion polarization projection
+            ! if (abs(prs(prin)%polprojin(lout)) .eq. 1 .and. &
+            !     (massive_fermion .or. massive_anti_fermion)) then
+            !   pidc = anti(pid)
+            !   if (prs(prin)%polprojin(lout) .eq. +1) then
+            !     if (massive_fermion) then
+            !       polsel = -1
+            !     else
+            !       polsel = 1
+            !     end if
+            !   else
+            !     if (massive_fermion) then
+            !       polsel =  1
+            !     else
+            !       polsel =  -1
+            !     end if
+            !   end if
+
+            !   call definewp (   &
+            !        pidc,        &
+            !        p(:,lout),   &
+            !        pl(:,lout),  &
+            !        mass_proj,   &
+            !        -polsel,     &
+            !        pol1a)
+
+            !   call definewp (    &
+            !        pid,          &
+            !        -p(:,lout),   &
+            !        -pl(:,lout),  &
+            !        mass_proj,    &
+            !        polsel,       &
+            !        pol1b)
+
+            !   ! check
+            !   !call definewp (   &
+            !   !     pidc,        &
+            !   !     p(:,lout),   &
+            !   !     pl(:,lout),  &
+            !   !     mass_proj,   &
+            !   !     polsel,      &
+            !   !     pol1c)
+            !   !call definewp (   &
+            !   !     pid,         &
+            !   !     -p(:,lout),  &
+            !   !     -pl(:,lout), &
+            !   !     mass_proj,   &
+            !   !     -polsel,     &
+            !   !     pol1d)
+
+            !   ! checks
+            !   !! sum(u ubar) = pslash + m
+            !   !do k = 1, 4
+            !   !  do j = 1, 4
+            !   !    pslm_2(k,j) = pol1a(k-1)*pol1b(j-1) + pol1c(k-1)*pol1d(j-1)
+            !   !  end do
+            !   !end do
+            !   !do k = 0, 3
+            !   !  write(*,*) "ww0out(k,mo):", ww0out(k,mo)
+            !   !end do
+
+            !   ! Whiy is the following necessary? Doesn't it overwrites the previous defined ww0out?
+            !   ! compute current and truncate full propagator
+            !   call tree3 (.true.,ps(lout),p(:,leg1),p(:,leg2), &
+            !       pl(:,leg1),pl(:,leg2),m2,den,co(1:2),ty,     &
+            !       ww0(:,w0in(1)),ww0(:,w0in(2)),ww0out(:,mo) )
+
+            !   ! add back propagator denominator
+            !   ww0out(:,mo) = cId0*ww0out(:,mo)/den
+
+            !   !write(*,*)
+            !   !do k = 1, 4
+            !   !  write(*,*) "sum(ww0out(0:,mo)*pslm_2(1:,k)):", &
+            !   !  sum(ww0out(0:,mo)*pslm_2(k, 1:))
+            !   !end do
+
+            !   if (massive_fermion) then
+            !     ww0out(:,mo) = sum(ww0out(:,mo)*pol1b(:))*pol1a(:)
+            !   else
+            !     ! this sign has been fixed by the requirement that the
+            !     ! full polarization sum should reproduce the original
+            !     ! current, i.e.:
+            !     ! ww0out(:,mo) = -sum(ww0out(:,mo)*pol1b(:))*pol1a(:)
+            !     !                -sum(ww0out(:,mo)*pol1d(:))*pol1c(:)
+            !     !              == ww0out_orig(:,mo)
+            !     ww0out(:,mo) = -sum(ww0out(:,mo)*pol1b(:))*pol1a(:)
+            !   end if
+            ! end if
+
+            ! if ((prs(prin)%polprojin(lout) .eq. 3) .and. &
+            !     (massive_fermion .or. massive_anti_fermion)) then
+            !     write(*,*) "Coherent polarization sum not implemented" // &
+            !                 " for massive fermions."
+            !     stop 9
+            ! end if
+
+            ! Goldstone contributions for polarisation:
+            if (npoint .gt. 2) then
+                ! Ghosts & Goldstone boson - transverse & coherent sum
+              if (drop_goldstone_transverse .and. &
+                  (abs(prs(prin)%polprojin(lout)) .eq. 1 .or. &
+                  (prs(prin)%polprojin(lout) .eq. 3)) .and. &
+                  goldstone_boson) then
+                ww0out(:,mo) = 0
+              end if
+
+              ! Ghosts & Goldstone boson - longitudinal
+              if (drop_goldstone_longitudinal .and. &
+                  ((prs(prin)%polprojin(lout) .eq. 0)) .and. &
+                  goldstone_boson) then
+                ww0out(:,mo) = 0
+              end if
+
+              ! Ghosts & Goldstone boson - everything
+              if (drop_goldstone_longitudinal .and. &
+                  drop_goldstone_transverse .and. &
+                  ((prs(prin)%polprojin(lout) .eq. 4)) .and. &
+                  goldstone_boson) then
+                ww0out(:,mo) = 0
+              end if
+            endif
+
             if (last) then
               wwTI = sum(ww0out(:,mo)*ww0(:,w0i))
               matrix(cs,gs,i,lp,prin) = matrix(cs,gs,i,lp,prin) + wwTI
@@ -2971,7 +3221,7 @@ module amplitude_rcl
       write(nx,'(2x,5a)') &
         'The denominator of the propagator of resonance number ', &
         trim(adjustl(ci)),' (',trim(cpa),' particle) '
-      write(nx,'(2x,a)') 'carries an off-sheel squared momentum p^2:'
+      write(nx,'(2x,a)') 'carries an off-shell squared momentum p^2:'
       write(nx,'(4x,a,'//trim(fmtp2)//',a)') 'p^2       = ',p2,' GeV^2'
       write(nx,'(4x,a,'//trim(fmtpm)//',a)') 'sqrt(p^2) = ',pm,' GeV'
       write(nx,*)
diff --git a/src/core/currents_rcl.f90 b/src/core/currents_rcl.f90
index 791f5da..be793f0 100644
--- a/src/core/currents_rcl.f90
+++ b/src/core/currents_rcl.f90
@@ -621,6 +621,37 @@ module currents_rcl
         end if
       end do
 
+      if (sav .eq. 1) then
+        ! translate vector polarizations to internal (permutated) ones
+        tlm1 = 2**(legs-1)
+        tl   = 2**legs
+        do i = 1, tlm1-1
+          if (prs(pr)%polproj(i) .ne. nopol) then
+            j = 0
+            do k = 1,legs
+              if (iand(2**(k-1), i) .ne. 0) then
+                j = j + 2**(newleg(k,pr)-1)
+              end if
+            end do
+
+            prs(pr)%polprojin(j) = prs(pr)%polproj(i)
+
+            ! polprojin (used in amplitude_rcl) opposed to polproj stores the
+            ! projections of all the momenta, i.e. 2**(lmax)-1 momenta
+            ! here we enter the case for: p -> -p
+            j  = tl - 1 - j
+
+            ! flip helicity for transversal polarization for opposite
+            ! propagation direction
+            if (abs(prs(pr)%polproj(i)) .eq. 1) then
+              prs(pr)%polprojin(j) = -prs(pr)%polproj(i)
+            else
+              prs(pr)%polprojin(j) = prs(pr)%polproj(i)
+            end if
+          end if
+        end do
+      end if
+
       if (prs(pr)%loop) then
         allocate (park(legs+2))
       else
diff --git a/src/core/globals_rcl.f90.in b/src/core/globals_rcl.f90.in
index 23a5641..427daec 100644
--- a/src/core/globals_rcl.f90.in
+++ b/src/core/globals_rcl.f90.in
@@ -298,6 +298,11 @@ module globals_rcl
     integer, allocatable :: binRes(:)      ! Resonances (propagator ids)
     integer, allocatable :: parRes(:)      ! Resonances (particle ids)
     integer, allocatable :: qflow(:)       ! Quark-flow restrictions
+
+    ! vector-boson polarisation projection
+    integer, allocatable :: polproj(:)     ! Helicities for projection, specified by the user.
+    integer, allocatable :: polprojin(:)   ! Helicities for projection, for internal use.
+
     integer, allocatable :: powsel(:,:,:)  ! Coupling power selections
     integer, allocatable :: relperm(:)     ! Relative permutation
     integer, allocatable :: colcoef(:,:)
@@ -329,6 +334,12 @@ module globals_rcl
 ! amplitude
   logical :: longitudinal_nlo = .true.
 
+  ! vector-boson polarisation projection
+  logical :: drop_goldstone_transverse = .true.
+  logical :: drop_goldstone_longitudinal = .true.
+  ! no polarisation set parameter
+  integer, parameter     :: nopol=-2
+
 !hard-coded dressing functions
 
   integer, parameter :: &
diff --git a/src/core/wave_functions_rcl.f90 b/src/core/wave_functions_rcl.f90
index 53b05a1..89cbbb5 100644
--- a/src/core/wave_functions_rcl.f90
+++ b/src/core/wave_functions_rcl.f90
@@ -37,7 +37,7 @@ module wave_functions_rcl
   complex (dp), intent (out) :: wp(0:3)
 
   real(dp)       :: s0,s3,p0p3
-  complex(dp)    :: m,pv,pT,r,php,phm,bp,bm,bhp,bhm,ap,am
+  complex(dp)    :: m,pv,pT,r,php,phm,bp,bm,bhp,bhm,ap,am,mo,mo2
   logical        :: pTzero
 
   ! pl(1) = p(0)+p(3)
@@ -68,7 +68,7 @@ module wave_functions_rcl
     select case (hel)
 
     case (0)
-
+      ! Longitudinal polarisation vector
       wp(0) = pv/m
       if (pTzero) then ! pT = 0 (i.e. p(1)/pT = s0, p(2)/pT = 0)
         wp(1:2) = cnul
@@ -78,7 +78,7 @@ module wave_functions_rcl
       endif
 
     case (-1,1)
-
+      ! Transverse polarisation vectors
       wp(0) = cnul
       if (pTzero) then ! pT = 0 (i.e. p(1)/pT = s0, p(2)/pT = 0)
         wp(1) = - hel*s3/csq2
@@ -89,6 +89,20 @@ module wave_functions_rcl
         wp(2) = ( - s0*hel*p(2)*p(3)/pv - cima*p(1) )/csq2/pT
         wp(3) = s0*hel*pT/csq2/pv
       endif
+
+    case (2)
+      ! Auxiliary polarisation vector
+      mo2 = pl(1)*pl(2) - pl(3)*pl(4)
+      mo = sqrt(mo2)
+      wp(0) = p(0)/mo
+      if (pTzero) then ! pT = 0 (i.e. p(1)/pT = s0, p(2)/pT = 0)
+        wp(1:2) = cnul
+        wp(3)   = s3*pv/mo
+      else             ! pT > 0 (this implies pv > 0)
+        wp(1:3) = p(1:3)/mo
+      endif
+
+      wp(:) = wp(:)*sqrt(mo2/m**2-1d0)
     end select
 
   ! fermions
diff --git a/src/pyrecola/pyrecola.c b/src/pyrecola/pyrecola.c
index 1d92806..6b8053a 100644
--- a/src/pyrecola/pyrecola.c
+++ b/src/pyrecola/pyrecola.c
@@ -910,7 +910,7 @@ switchon_resonant_selfenergies_py(PyObject *self, PyObject *args)
 }
 PyDoc_STRVAR(switchoff_resonant_selfenergies_doc,
 "switchoff_resonant_selfenergies_rcl\n\n\
-Sets the value of `resSE` to .true.");
+Sets the value of `resSE` to .false.");
 static PyObject *
 switchoff_resonant_selfenergies_py(PyObject *self, PyObject *args)
 {
@@ -1294,6 +1294,61 @@ set_resonant_particle_py(PyObject *self, PyObject *args)
   Py_INCREF(Py_None);
   return Py_None;
 }
+PyDoc_STRVAR(set_internal_projection_doc,
+"set_internal_projection_rcl(npr,v,p)\n\n\
+Select polarization of massive intermediate particle.\n\
+Args:\n\
+  npr (int): process number\n\
+  v (int): particle binary id\n\
+  p (int): polarisation state: -1, 0, +1, 3\n\n\
+Note:\n\
+  The internal lines, for which the projection\n\
+  is done, need to be on-shell. Usually, the pole-\n\
+  approximation is used for that.\n\
+  p = 3 can be selected to get the transverse polarization\n\
+  contribution, i.e. the add-up left- and right-handed\n\
+  polarization contributions.\n\n\
+Examples:\n\
+  External particle are identified by binaries, i.e. in this example\n\
+  1 (u), 2 (u~), e+(4), nu_e(8), mu-(16), nu_mu~(32), g(64)\n\
+  Define the process:\n\
+  >>> call define_process_rcl(1, 'u u~ > e+ nu_e mu- nu_mu~ g', 'LO')\n\
+  Set the polarisation of the internal W^+ line:\n\
+  >>> call set_internal_projection_rcl(1, 12, -1)\n\
+  12 refers to e+ (4) + nu_e (8)\n\
+  Set the polarisation of the internal W^- line:\n\
+  call set_internal_projection_rcl(1, 48, -1)\n\
+  48 refers to mu- (16) + nu_mu~ (32)");
+static PyObject *
+set_internal_projection_py(PyObject *self, PyObject *args)
+{
+  int npr,v,p;
+
+  if (!PyArg_ParseTuple(args, "iii", &npr,&v,&p))
+      return NULL;
+
+  set_internal_projection_rcl(npr,v,p);
+
+  Py_INCREF(Py_None);
+  return Py_None;
+}
+PyDoc_STRVAR(update_internal_projection_doc,
+"update_internal_projection_rcl(npr,v,p)\n\n\
+Do the same as set_internal_projection_rcl but\n\
+also update the internally used polprojin array.");
+static PyObject *
+update_internal_projection_py(PyObject *self, PyObject *args)
+{
+  int npr,v,p;
+
+  if (!PyArg_ParseTuple(args, "iii", &npr,&v,&p))
+      return NULL;
+
+  update_internal_projection_rcl(npr,v,p);
+
+  Py_INCREF(Py_None);
+  return Py_None;
+}
 PyDoc_STRVAR(set_quarkline_doc,
 "set_quarkline_rcl(npr,q1,q2)\n\n\
 Enforces a quark-flow between two quarks ``q1`` and ``q2``.\n\n\
@@ -1377,6 +1432,32 @@ print_collier_statistics_py(PyObject *self, PyObject *args)
   Py_INCREF(Py_None);
   return Py_None;
 }
+PyDoc_STRVAR(initialise_particles_doc,
+"initialise_particles_rcl\n\n\
+Initialises the some electroweak parameters of the model before the process is generated.");
+static PyObject *
+initialise_particles_py(PyObject *self, PyObject *args)
+{
+
+  initialise_particles_rcl();
+
+  Py_INCREF(Py_None);
+  return Py_None;
+}
+PyDoc_STRVAR(clear_particles_doc,
+"clear_particles_rcl\n\n\
+Call the model internal clear_particles_mdl routine and reset a lot of model parameters.\n\
+This routine is supposed to be used in combination with a call of initialise_particles_rcl before\n\
+and both calls are expected to be made before the process is generated.");
+static PyObject *
+clear_particles_py(PyObject *self, PyObject *args)
+{
+
+  clear_particles_rcl();
+
+  Py_INCREF(Py_None);
+  return Py_None;
+}
 
 // additional stuff, only used in combination with rept1l
 static PyObject *
@@ -4821,11 +4902,15 @@ static PyMethodDef pyrecola_methods[] = {
   {"get_parameter_rcl", get_parameter_py, METH_VARARGS, get_parameter_doc},
   {"set_renoscheme_rcl", set_renoscheme_py, METH_VARARGS, set_renoscheme_doc},
   {"set_resonant_particle_rcl", set_resonant_particle_py, METH_VARARGS, set_resonant_particle_doc},
+  {"set_internal_projection_rcl", set_internal_projection_py, METH_VARARGS, set_internal_projection_doc},
+  {"update_internal_projection_rcl", update_internal_projection_py, METH_VARARGS, update_internal_projection_doc},
   {"set_quarkline_rcl", set_quarkline_py, METH_VARARGS, set_quarkline_doc},
   {"reset_vertices_rcl", reset_vertices_py, METH_VARARGS, reset_vertices_doc},
   {"reset_couplings_rcl", reset_couplings_py, METH_VARARGS, reset_couplings_doc},
   {"reset_ctcouplings_rcl", reset_ctcouplings_py, METH_VARARGS, reset_ctcouplings_doc},
   {"print_collier_statistics_rcl", print_collier_statistics_py, METH_VARARGS, print_collier_statistics_doc},
+  {"initialise_particles_rcl", initialise_particles_py, METH_VARARGS, initialise_particles_doc},
+  {"clear_particles_rcl", clear_particles_py, METH_VARARGS, clear_particles_doc},
   // additional stuff, only used in combination with rept1l
   {"set_compute_selfenergy_rcl", set_compute_selfenergy_py, METH_VARARGS},
   {"set_compute_selfenergy_offshell_rcl", set_compute_selfenergy_offshell_py, METH_VARARGS},
diff --git a/src/recola.f90 b/src/recola.f90
index dcc436b..56da205 100644
--- a/src/recola.f90
+++ b/src/recola.f90
@@ -60,6 +60,8 @@
       scale_coupling4_rcl,                   &
       switchoff_coupling3_rcl,               &
       switchoff_coupling4_rcl,               &
+      initialise_particles_rcl,              &
+      clear_particles_rcl,                   &
       switchon_resonant_selfenergies_rcl,    &
       switchoff_resonant_selfenergies_rcl,   &
       set_dynamic_settings_rcl,              &
@@ -83,6 +85,8 @@
       set_renoscheme_rcl,                    &
       get_renoscheme_rcl,                    &
       set_resonant_particle_rcl,             &
+      set_internal_projection_rcl,           &
+      update_internal_projection_rcl,        &
       set_quarkline_rcl,                     &
       set_otter_mode_rcl,                    &
       reset_vertices_rcl,                    &
diff --git a/src/util/draw_current_rcl.f90 b/src/util/draw_current_rcl.f90
index cc44ab5..3be4973 100644
--- a/src/util/draw_current_rcl.f90
+++ b/src/util/draw_current_rcl.f90
@@ -42,7 +42,7 @@ module draw_current_rcl
 
       write(99,'(a)') '\documentclass[11pt]{article}'
       write(99,'(a)')
-      write(99,'(a)') '\usepackage{axodraw}'
+      write(99,'(a)') '\usepackage{axodraw2}'
       write(99,'(a)')
       write(99,'(a)') '\oddsidemargin -20pt \evensidemargin -20pt'
       write(99,'(a)') '\topmargin -40pt \headheight 00pt \headsep 00pt'
